<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>【STL】STL体系结构概述</title>
    <link href="/2023/12/23/%E3%80%90STL%E3%80%91STL%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/"/>
    <url>/2023/12/23/%E3%80%90STL%E3%80%91STL%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<div class="note note-primary">            <p>本文将是STL系列的第一篇文章，主要参考《STL源码剖析》，辅以网络博文，不定时更新我感兴趣的内容。</p>          </div><span id="more"></span><p>笔者在入门<code>C++</code>这门编程语言的时候之前，就已听腻了这个<code>STL</code>这个词了，特别是在<strong>OJ场景</strong>下，主要是因为采用这个库就可以避免手撸一些数据结构，有相关数据结构基础就能直接上手了。当然，这都是对<code>STL</code>比较浅显的认知罢了，本系列将开始学习<code>STL</code>的相关知识。</p><h2 id="STL是什么？"><a href="#STL是什么？" class="headerlink" title="STL是什么？"></a>STL是什么？</h2><p><code>STL</code>是<code>Standard Template Library</code>的缩写，中文译作<strong>标准模板库</strong>，属于C++标准库的一部分。</p><blockquote><p><code>STL</code>所实现的，是依据泛型思想架设起来的一个概念结构。这个以抽象概念（abstract concepts）为主体而非以实际类（classes）为主体的结构，形成了一个严谨的接口标准。在此接口之下，任何组件都有最大的独立性，并以所谓的迭代器（iterator）胶合起来，或以适配器（adapter）互相适配，或以所谓仿函数（functor）动态选择某种策略（policy或strategy）。</p></blockquote><h2 id="STL的六大组件"><a href="#STL的六大组件" class="headerlink" title="STL的六大组件"></a>STL的六大组件</h2><p><code>STL</code>提供六大组件，彼此之间相辅相成：</p><ul><li><strong>容器（containers）</strong>：各种数据结构，如<code>vector</code>、<code>list</code>、<code>deque</code>、<code>map</code>、<code>set</code>用来存储数据。从实现上来说，<code>STL</code>容器是<code>class template</code>，也就是说它能够支持不同类型的元素（前提是需要满足容器要求）。</li><li><strong>算法（algorithms）</strong>：各种常用算法，如<code>sort</code>、<code>search</code>、<code>copy</code>等。从实现上来说，它是一种<code>function template</code>。</li><li><strong>迭代器（iterators）</strong>：扮演容器与算法之间的胶合剂，是一种“泛型指针”，也可以理解成抽象化的指针，实现上是<strong>借助了C++中的操作符重载</strong>的特性，所有的<code>STL</code>容器都<strong>附带了一套属于自己的专属迭代器</strong>。原生指针（native pointer）也是一种迭代器。</li><li><strong>仿函数（functiors）：</strong>行为类似于函数，可作为算法的某种策略（<strong>policy</strong>）。从实现上来说，其实就是一种重载了<code>operator ()</code>的<code>class</code>或<code>class template</code>，比如<code>lambda</code>表达式也是其中一种。</li><li><strong>配接器（adapters）</strong>：适配器，一种用来修饰容器（containter）或仿函数（functiors）或迭代器接口的东西。比如，<code>STL</code>中提供的<code>queue</code>和<code>stack</code>是一种容器适配器，底层默认是<code>deque</code>容器。改变<code>functor</code>者，称之为<code>function adapter</code>；改变<code>container</code>接口者，称为<code>container adapter</code>；改变<code>iterator</code>接口者，称为<code>iterator adapter</code>。</li><li><strong>配置器（allocators）</strong>：分配器，负责空间的配置和管理。从实现上看，它是一个实现了动态空间配置、空间管理、空间释放的<code>class template</code>。</li></ul><p>它们之间的关系可以用下图进行表示：</p><p><img src="关系图.jpg" alt="关系图"></p><blockquote><p>要理解这张图，需要读者结合上面对六大组件的简单解释来分析，如果还有一些<code>STL</code>使用经历就更好了。</p></blockquote><h2 id="STL的实现版本"><a href="#STL的实现版本" class="headerlink" title="STL的实现版本"></a>STL的实现版本</h2><p>在学习<code>C++</code>过程，大家需要理解一个概念就是：<strong>我们学习的是一个标准（C++11、C++14、C++17等标准），而具体实现依据不同编译器，标准没规定的就是由编译器自由发挥了。</strong>在标准中没规定的东西，不要从某一个编译器实现中看到它的实现方式就说<code>C++</code>对这个一定是这样实现的，这是一种思维误区，这是不对的。</p><p><code>STL</code>实现主要有以下的版本：</p><ul><li><strong>HP实现的版本</strong>：所有<code>STL</code>实现的始祖</li><li><strong>P.J.Plauger实现的版本</strong>：继承于HP版本，被<strong>Visual C++</strong>采用</li><li><strong>Rouge Wave实现的版本</strong>：继承于HP版本，被<strong>C++Builder</strong>采用</li><li><strong>STLPort实现的版本</strong>：提供一个以<code>SGI STL</code>为蓝本的高度可移植性实现的版本</li><li><strong>SGI STL实现的版本</strong>：同样继承自HP版本，被<strong>GCC</strong>采用</li></ul><p>在侯捷的《STL源码剖析》一书中分析的便是<strong>SGI STL实现的版本</strong>。一方面，<code>GCC</code>对<code>C++</code>的支持性比较高，使用率也比较高，大家平常接触得比较多的也应该是这个版本，分析这个版本的内容，也更好了解<code>GCC</code>；另一方面，<code>SGI STL</code>版本可读性很高，值得学习。</p><h2 id="额外补充"><a href="#额外补充" class="headerlink" title="额外补充"></a>额外补充</h2><h3 id="一、容器范围区间"><a href="#一、容器范围区间" class="headerlink" title="一、容器范围区间"></a>一、容器范围区间</h3><p>容器提供的范围区间一般是遵循<strong>前闭后开</strong>即<code>[)</code>的原则。典型地，就是来自<code>begin()</code>、<code>end()</code>函数返回的这两个迭代器所指代的范围：</p><p><img src="image-20231223000602357.png" alt="image-20231223000602357"></p><p><code>begin（）</code>返回的迭代器指向了容器元素中的第一个，而<code>end()</code>返回的迭代器则是<strong>容器元素中的最后一个的下一个（不存在的元素）</strong>。这是一个例子，其他的返回区间，也是遵循这一原则。</p><h3 id="二、容器结构与分类"><a href="#二、容器结构与分类" class="headerlink" title="二、容器结构与分类"></a>二、容器结构与分类</h3><p>容器主要可以分为两大类：</p><ul><li>序列式容器（<strong>SequenceContainer</strong>）：在线性排列中存储相同类型对象的容器</li><li>关联容器（<strong>AssociativeContainer</strong>）：提供基于键的快速对象查找的容器</li></ul><h4 id="序列式容器"><a href="#序列式容器" class="headerlink" title="序列式容器"></a>序列式容器</h4><p>序列式容器底层是<strong>采用类似线性表的结构来存储元素</strong>：</p><ol><li><code>array</code>：于C++11标准引入，功能等同于传统数组，但<strong>它不会退化为指针</strong>，还能提供容器相关的操作</li><li><code>vector</code>：封装动态数组的序列容器，特点是 <strong>存储动态管理，尾部扩增</strong>，在<code>GCC</code>中，其增长空间是以2倍增长的</li><li><code>deque</code>：双端队列，头尾两端可增可减，内部存储的方式是以<strong>分段模拟连续空间</strong>（关键靠迭代器），访问元素需要两层指针访问。</li><li><code>list</code>：通常实现为<strong>双向链表</strong>，支持从容器任何位置进行常数时间的元素插入和移除，不支持随机访问。</li><li><code>forward_list</code>：于C++11标准引入，通常实现为<strong>单链表</strong>，支持从容器中的任何位置快速插入和移除元素的容器，不支持随机访问。</li></ol><blockquote><p>序列式容器不止上述这些，随着新标准的引入，相信也会有新的容器加入到<code>STL</code>中，建议关注：<a href="https://en.cppreference.com/w/">cppreference.com</a></p></blockquote><h4 id="关联容器"><a href="#关联容器" class="headerlink" title="关联容器"></a>关联容器</h4><ul><li>有序关联容器：底层通常采用<strong>红黑树</strong>实现</li><li>不定序关联容器：底层通常采用哈希表<strong>哈希表</strong>实现</li></ul><h5 id="有序关联容器"><a href="#有序关联容器" class="headerlink" title="有序关联容器"></a>有序关联容器</h5><ol><li><code>set</code>：只存储<code>Key</code>类型的对象，有序，<code>Key</code>唯一</li><li><code>multiset</code>：只存储<code>Key</code>类型的对象，有序，<code>Key</code>允许重复</li><li><code>map</code>：存储键值对，有序，<code>Key</code>唯一</li><li><code>multimap</code>：存储键值对，有序，<code>Key</code>允许重复</li></ol><h5 id="不定序关联容器"><a href="#不定序关联容器" class="headerlink" title="不定序关联容器"></a>不定序关联容器</h5><ol><li><code>unordered_set</code>：只存储<code>Key</code>类型的对象，无特别的顺序，只是组织到桶中，依赖hash值，<code>Key</code>唯一</li><li><code>unordered_multiset</code>：只存储<code>Key</code>类型的对象，无特别的顺序，只是组织到桶中，依赖hash值，<code>Key</code>允许重复</li><li><code>unordered_map</code>：存储键值对，无特别顺序，只是组织到桶中，依赖hash值，<code>Key</code>唯一</li><li><code>unordered_multimap</code>：存储键值对，无特别顺序，只是组织到桶中，依赖hash值，<code>Key</code>允许重复</li></ol><blockquote><p>当然，关联式容器也不止这些，这里只是简单做个介绍。</p></blockquote><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://zh.cppreference.com/w/cpp/container">容器库 - cppreference.com</a></li><li><a href="https://book.douban.com/subject/1110934/">STL源码剖析 (豆瓣) (douban.com)</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>STL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C/C++</tag>
      
      <tag>STL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一种解决Qt5发布release文件引发的无法定位程序输入点错误的方法</title>
    <link href="/2023/12/17/%E4%B8%80%E7%A7%8D%E8%A7%A3%E5%86%B3QT5%E5%8F%91%E5%B8%83release%E6%96%87%E4%BB%B6%E5%BC%95%E5%8F%91%E7%9A%84%E6%97%A0%E6%B3%95%E5%AE%9A%E4%BD%8D%E7%A8%8B%E5%BA%8F%E8%BE%93%E5%85%A5%E7%82%B9%E9%94%99%E8%AF%AF%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <url>/2023/12/17/%E4%B8%80%E7%A7%8D%E8%A7%A3%E5%86%B3QT5%E5%8F%91%E5%B8%83release%E6%96%87%E4%BB%B6%E5%BC%95%E5%8F%91%E7%9A%84%E6%97%A0%E6%B3%95%E5%AE%9A%E4%BD%8D%E7%A8%8B%E5%BA%8F%E8%BE%93%E5%85%A5%E7%82%B9%E9%94%99%E8%AF%AF%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<div class="note note-primary">            <p>本文主要介绍Qt5发布release文件时出现无法定位程序输入点错误的可能原因以及解决方法。</p>          </div><span id="more"></span><h2 id="本地环境"><a href="#本地环境" class="headerlink" title="本地环境"></a>本地环境</h2><blockquote><p>本文将不会解释如何利用Qt5编译生成release类型的可执行文件以及如何利用<code>windeployqt</code>生成可执行的依赖库，请自行百度。</p></blockquote><div class="table-container"><table><thead><tr><th style="text-align:center">环境</th><th style="text-align:center">值</th></tr></thead><tbody><tr><td style="text-align:center">操作系统</td><td style="text-align:center">Windows 10 专业版（22H2）</td></tr><tr><td style="text-align:center">Qt版本</td><td style="text-align:center">Qt 5.15.2</td></tr><tr><td style="text-align:center">Qt Creator版本</td><td style="text-align:center">5.0.2</td></tr><tr><td style="text-align:center">编译器版本</td><td style="text-align:center">g++ (x86_64-posix-seh-rev0, Built by MinGW-W64 project) 7.3.0</td></tr><tr><td style="text-align:center">发布类型</td><td style="text-align:center">release</td></tr><tr><td style="text-align:center">windeployqt 版本</td><td style="text-align:center">Qt Deploy Tool 5.12.12</td></tr></tbody></table></div><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>编写完程序后直接利用Qt Creator发布release版本的可执行文件（exe后缀），随后再执行如下命令获取与可执行文件相关的依赖库：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">windeployqt [可执行文件]<br></code></pre></td></tr></table></figure><p>发现确实<strong>生成一大堆*.dll</strong>，总目录大小高达900+MB：</p><p><img src="image-20231217144839675.png" alt="image-20231217144839675"></p><p>双击<code>*.exe</code>文件，提示<strong>“无法定位程序输入点_ZN10QArrayData10deallocateEPs_yy”</strong>：</p><p><img src="image-20231217144707540.png" alt="image-20231217144707540"></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>起初，以为是编译器版本不对的问题，仔细对比了我用<code>windeployqt</code>工具时进入的环境以及我在<code>Qt creator</code>软件编译的环境，发现并没有什么问题，但是网上采用同样的方式均能成功运行<code>*.exe</code>文件，百思不得其解。</p><p>后来我根据<strong>关键词”Qt 无法定位程序输入点”</strong>寻找解决方案，大部分是描述依赖库的问题，我随便拿了一个动态库<code>libstdc++-6.dll</code>比对了我手头其他<code>MinGW</code>的环境，发现其实生成的这个动态库确实是编译环境中的依赖库，并没有出错。</p><p>此外，我还以为是本机的问题，便尝试将该文件以及依赖库传输到另外一台电脑运行，发现依然是同样的问题，还注意到了这些文件居然<strong>高达900+MB</strong>，这我开始怀疑是不是发布的包选错了，我写的程序仅仅几个文件，后续还是没有发现有什么错误的点。</p><p>当我重新使用<code>windeployqt</code>生成时，瞧了一眼日志信息，嘿，居然是以<strong>debug executable</strong>模式生成依赖库的：</p><p><img src="image-20231217144622703.png" alt="image-20231217144622703"></p><p>所以这肯定是会出现问题的，一个以<code>Release</code>方式生成的可执行文件，依赖库却按<strong>debug executable</strong>模式构建，必然出现这种找不到程序入口的问题。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>在使用<code>windeployqt</code>工具构建依赖库时，强制它使用<code>release</code>模式：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">windeployqt [可执行文件] -<span class="hljs-literal">-release</span><br></code></pre></td></tr></table></figure><p>这样就没有问题了，可以看到生成的这些依赖库以及可执行文件总大小才几十兆（未优化）：</p><p><img src="image-20231217144919121.png" alt="image-20231217144919121"></p>]]></content>
    
    
    <categories>
      
      <category>Bug</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C/C++</tag>
      
      <tag>Qt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解决[Unable to determine the device handle for GPU...: Unknown Error]问题</title>
    <link href="/2023/11/03/%E8%A7%A3%E5%86%B3-Unable-to-determine-the-device-handle-for-GPU-Unknown-Error-%E9%97%AE%E9%A2%98/"/>
    <url>/2023/11/03/%E8%A7%A3%E5%86%B3-Unable-to-determine-the-device-handle-for-GPU-Unknown-Error-%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<blockquote><p>解决Ubuntu系统上的[Unable to determine the device handle for GPU…: Unknown Error]问题<span id="more"></span></p></blockquote><h2 id="服务器环境"><a href="#服务器环境" class="headerlink" title="服务器环境"></a>服务器环境</h2><div class="table-container"><table><thead><tr><th style="text-align:center">环境</th><th>值</th></tr></thead><tbody><tr><td style="text-align:center">操作系统</td><td>Ubuntu-22.04</td></tr><tr><td style="text-align:center">内核</td><td>Linux 6.2.0-36-generic</td></tr><tr><td style="text-align:center">显卡</td><td>NVIDIA GeForce RTX 3090（2张）</td></tr></tbody></table></div><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>在<strong>跑一个大模型模块的训练</strong>时，发现GPU莫名奇妙地挂了，执行<code>nvidia-smi</code>报了如下错误：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">Unable to determine the device handle for GPU0000:01:00.0: Unknown Error<br></code></pre></td></tr></table></figure><p>而在重启之后，<strong>又能执行<code>nvidia-smi</code>显示所有显卡的信息</strong>，通过<code>lspci</code>命令查看<code>Linux</code>是否能正常读取<code>PCI</code>总线上挂载的设备，可以看到开机后，两个显卡的信息都是能读取的:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">01:00.0 VGA compatible controller: NVIDIA Corporation GA102 [GeForce RTX 3090] (rev a1)<br>01:00.1 Audio device: NVIDIA Corporation GA102 High Definition Audio Controller (rev a1)<br>02:00.0 VGA compatible controller: NVIDIA Corporation GA102 [GeForce RTX 3090] (rev a1)<br>02:00.1 Audio device: NVIDIA Corporation GA102 High Definition Audio Controller (rev a1)<br></code></pre></td></tr></table></figure><p>其中需要注意到后面<code>rev a1</code>信息都是正常的，<u>当发生上诉错误后（即显卡爆出一个未知的错误），其中被使用的显卡，也就显卡1中的<code>rev a1</code>变成了<code>rev ff</code>，无法正常读取</u>。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>首先考虑的是<strong>驱动问题</strong>，毕竟一般设备识别不出来，多半是驱动有点小<strong>bug</strong>。先去检查了原来的驱动，发现装的驱动版本是<code>535.86.05</code>，比较新的一个版本。按照个人习惯，<strong>会选择比当前最新的版本退两三个版本</strong>（其实就是怕麻烦，旧一些的版本遇到问题可以从网上找到更多例子，而新版本可能还得官方指定网站去寻求答案），参照网上的安装流程成功地把原有驱动卸载了并装回了<code>525.147.05</code>版本，并尝试继续跑算法，<strong>但是没能解决问题</strong>。在这里还遇到了另一个问题，也就是<strong>图形界面无法正常启动/渲染了</strong>，强制重启也没法进入系统了。个人猜测，主要是我更换驱动没做好配套工作，遇到这样的情况，我首先尝试在进入系统前利用<code>ctrl+alt</code>+<code>F1~F10</code> 组合键进入到命令行界面，将现有驱动卸载了并装回原有驱动，成功进入界面（这里只有两个建议 <strong>1. 装显卡驱动一定要小心，多看文档再实操；2.备份驱动</strong>）。如果还是没法解决，可能就得重装系统了。</p><p>随后开始进一步分析问题，从被使用的显卡的版本信息由<code>rev a1-&gt; rev ff</code>知道<strong>显卡是在运行时被关闭了</strong>，在参考文章<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="NVIDIA显卡BUG解决 Unable to determine the device handle for GPU 0000:02:00.0: Unknown Error-CSDN博客">[1]</span></a></sup>列举的多种问题中，我大致猜到是<strong>GPU功率与电源相关的问题</strong>了，并从中跳转到了英伟达官网网站对应issue<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="Unable to determine the device handle for GPU 0000:02:00.0: Unknown Error - Graphics / Linux / Linux - NVIDIA Developer Forums">[2]</span></a></sup>词条下，发现利用执行如下命令暂时禁掉显卡1后能够执行<code>nvidia-smi</code>获取显卡2的信息了:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> sudo nvidia-smi drain -p 0000:01:00.0 -m 1</span><br></code></pre></td></tr></table></figure><blockquote><p>这里的 <code>-m</code> 是指GPU的计算模式，默认是0，即default,；<strong>1是指PROHIBITED，即禁止任务在它上面执行。</strong></p></blockquote><p>再利用<code>sudo nvidia-bug-report.sh</code>命令收集显卡的<code>bug</code>信息，从中查找到了与该Issue一致的问题:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">Xid (...): 79, pid=&#x27;&lt;unknown&gt;&#x27;, name=&lt;unknown&gt;, GPU has fallen off the bus<br></code></pre></td></tr></table></figure><p>其中一位大佬提到原因如下：</p><blockquote><p>Running ML workloads will cause heavy spikes in power usage, so rather get a better PSU.</p></blockquote><p>在相关Issue<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="GPU fans go to max and graphics drivers hang - Graphics / Linux / Linux - NVIDIA Developer Forums">[3]</span></a></sup>找到了解决方案，在该issue中大佬提到:</p><blockquote><p>One of the gpus is shutting down. Since it’s not always the same one, I guess they’re not damaged but either overheating or lack of power occurs. Please monitor temperatures, check PSU.</p></blockquote><p>简单来说就是: 多半是<strong>过热、缺电</strong>。对应的解决方案在下一节给出，也是上面的大佬提到的。</p><p>如果你想问<code>PSU</code>是什么，参考文章<sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><span class="hint--top hint--rounded" aria-label="电源供应器 - 维基百科，自由的百科全书 (wikipedia.org)">[4]</span></a></sup>。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>执行如下命令调整显卡的时钟速度（实际就是锁住其最大功率）:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> sudo nvidia-smi -lgc 300,1500</span><br></code></pre></td></tr></table></figure><p><code>-lgc</code>的作用:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">-lgc  --lock-gpu-clocks=    Specifies &lt;minGpuClock,maxGpuClock&gt; clocks as a<br>                                pair (e.g. 1500,1500) that defines the range <br>                                of desired locked GPU clock speed in MHz.<br>                                Setting this will supercede application clocks<br>                                and take effect regardless if an app is running.<br>                                Input can also be a singular desired clock value<br>                                (e.g. &lt;GpuClockValue&gt;).<br></code></pre></td></tr></table></figure><p>该命令只是临时的，服务器重启后需要重新设置。可以往<code>/etc/rc.local</code>开机自启配置文件，新增这一条命令。</p><blockquote><p>如果没有这个文件，建议根据指定<code>ubuntu 2204</code>、开机自启等关键词从网上查找对应解决方案寻求答案。</p></blockquote><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://blog.csdn.net/qq_54478153/article/details/128202846">NVIDIA显卡BUG解决 Unable to determine the device handle for GPU 0000:02:00.0: Unknown Error-CSDN博客</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://forums.developer.nvidia.com/t/unable-to-determine-the-device-handle-for-gpu-000000-0-unknown-error/197974">Unable to determine the device handle for GPU 0000:02:00.0: Unknown Error - Graphics / Linux / Linux - NVIDIA Developer Forums</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a href="https://forums.developer.nvidia.com/t/gpu-fans-go-to-max-and-graphics-drivers-hang/222069">GPU fans go to max and graphics drivers hang - Graphics / Linux / Linux - NVIDIA Developer Forums</a><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:4" class="footnote-text"><span><a href="https://zh.wikipedia.org/zh-hans/電源供應器">电源供应器 - 维基百科，自由的百科全书 (wikipedia.org)</a><a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Bug</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++中的静态库与动态库</title>
    <link href="/2023/09/25/C-%E4%B8%AD%E7%9A%84%E9%9D%99%E6%80%81%E5%BA%93%E4%B8%8E%E5%8A%A8%E6%80%81%E5%BA%93/"/>
    <url>/2023/09/25/C-%E4%B8%AD%E7%9A%84%E9%9D%99%E6%80%81%E5%BA%93%E4%B8%8E%E5%8A%A8%E6%80%81%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<p>单独提这个<strong>库</strong>，我想我们在coding过程中，可能也会知道一两个词，如<em>标准库</em>、xx库等。库作为一组已编写好、组织好的、可复用的资源接口，可以被用于其他程序。很不夸张地说，很多程序都需要依赖一些底层依赖库，从而支撑它们完成一些基础工作。</p><span id="more"></span><p>库主要分为两种类型：<strong>静态库（static library）</strong>和<strong>动态库（shared library）</strong>。</p><h4 id="静态库"><a href="#静态库" class="headerlink" title="静态库"></a>静态库</h4><p>静态库是一个在链接过程中采用<strong>静态链接</strong>方式链接进可执行文件中的库文件，在静态链接方式中，<u>可执行文件会拷贝静态库中导出的接口并使其成为它的一部分</u>。在<code>Windows</code>系统中它主要是以<code>.lib</code>为后缀，而在<code>Linux</code>系统中，主要以<code>.a</code>为后缀。</p><h5 id="构建静态库"><a href="#构建静态库" class="headerlink" title="构建静态库"></a>构建静态库</h5><p>项目结构为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs txt">.<br>├── CMakeLists.txt<br>├── library.h<br>├── library.cpp<br></code></pre></td></tr></table></figure><p><code>CMakeLists.txt</code>中的内容为：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.26</span>)<br><span class="hljs-keyword">project</span>(library)<br><span class="hljs-keyword">set</span>(CMAKE_CXX_STANDARD <span class="hljs-number">11</span>)<br><span class="hljs-keyword">add_library</span>(library STATIC library.cpp)<br></code></pre></td></tr></table></figure><p><code>library.h</code>的内容为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> HELLO_LIB_LIBRARY_H</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> HELLO_LIB_LIBRARY_H</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-class"><span class="hljs-keyword">class</span>   <span class="hljs-title">Test</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Test</span><span class="hljs-params">(std::string str)</span></span>;<br>    <span class="hljs-function">std::string  <span class="hljs-title">getStr</span><span class="hljs-params">()</span> </span>;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getNum</span><span class="hljs-params">()</span> </span>;<br><span class="hljs-keyword">private</span>:<br>    std::string str_;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> num; <span class="hljs-comment">// count value</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span>  <span class="hljs-title">print</span><span class="hljs-params">()</span></span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span> <span class="hljs-comment">//HELLO_LIB_LIBRARY_H</span></span><br></code></pre></td></tr></table></figure><p><code>library.cpp</code>的内容为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;library.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">int</span> Test::num = <span class="hljs-number">0</span>; <span class="hljs-comment">// init</span><br>Test::<span class="hljs-built_in">Test</span>(std::string str):<span class="hljs-built_in">str_</span>(std::<span class="hljs-built_in">move</span>(str)) &#123;&#125;<br><span class="hljs-function">std::string <span class="hljs-title">Test::getStr</span><span class="hljs-params">()</span>  </span>&#123;<br>     ++num;<br>    <span class="hljs-keyword">return</span> str_;<br>&#125;<br> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Test::getNum</span><span class="hljs-params">()</span></span>&#123;<br>     <span class="hljs-keyword">return</span>  num;<br> &#125;<br><br></code></pre></td></tr></table></figure><p>采用<code>cmake</code>进行构建，即可生成对应的静态库文件，在<code>Window</code>环境下将会生成<code>library.lib</code>，而在<code>Linux</code>环境下将会生成<code>liblibrary.a</code>。</p><p>随后可以在另一个项目中使用它，项目结构为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs txt">.<br>├── build<br>├── CMakeLists.txt<br>├── include<br>│   └── library.h<br>├── lib<br>│   └── library.lib<br>└── src<br>    └── main.cc<br></code></pre></td></tr></table></figure><p><code>CmakeLists.txt</code>的内容为：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.10</span>)<br><br><span class="hljs-keyword">project</span>(lib_test)<br><br><span class="hljs-keyword">set</span>(CMAKE_CXX_STANDARD <span class="hljs-number">11</span>)<br><span class="hljs-keyword">include_directories</span>(<span class="hljs-keyword">include</span>)<br><span class="hljs-comment"># 增加链接库的搜索路径</span><br><span class="hljs-keyword">link_directories</span>(lib)<br><span class="hljs-comment"># 链接 library库</span><br><span class="hljs-keyword">link_libraries</span>(library)<br><span class="hljs-keyword">add_executable</span>(<span class="hljs-variable">$&#123;PROJECT_NAME&#125;</span> src/main.cc)<br></code></pre></td></tr></table></figure><p>而随后就可以在<code>main.cc</code>中使用它们了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&quot;library.h&quot;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">Test <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-string">&quot;Hello&quot;</span>)</span></span>;<br>    std::cout &lt;&lt; test.<span class="hljs-built_in">getStr</span>();<br>    std::cout &lt;&lt; Test::<span class="hljs-built_in">getNum</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="动态库"><a href="#动态库" class="headerlink" title="动态库"></a>动态库</h4><p>动态库也叫做共享库，<u>在<strong>编译时</strong>并不会将所导出的接口拷贝到可执行文件中，而是在<strong>运行时</strong>才会被程序所引用</u>。在<code>Windows</code>系统中它主要是以<code>.dll</code>为后缀，而在<code>Linux</code>系统中，主要以<code>.so</code>为后缀。需要特别注意的是，在<code>MSVC</code>编译器中，<code>Windows</code>环境下不仅生成<code>dll</code>后缀文件，还会生成<code>.lib</code>文件，<strong>该文件此刻的作用是作为一个<a href="https://learn.microsoft.com/zh-cn/cpp/build/linking-an-executable-to-a-dll?view=msvc-170">导入库</a></strong>。</p><h5 id="构建动态库"><a href="#构建动态库" class="headerlink" title="构建动态库"></a>构建动态库</h5><p>项目结构大体上和上述提到的构建的静态库一致，但还需要修改一下<code>CMakeLists</code>以及<code>library.h</code>（针对<code>MSVC</code>编译器，<code>Linux</code>环境、<code>MinGW-gcc</code>不用管）。</p><p><code>library.h</code>文件：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> HELLO_LIB_LIBRARY_H</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> HELLO_LIB_LIBRARY_H</span><br><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> EXPORTTING</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DECLSPEC __declspec(dllimport)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DECLSPEC __declspec(dllexport)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span> <span class="hljs-comment">// EXPORTTING</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DECLSPEC</span>  <span class="hljs-title">Test</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Test</span><span class="hljs-params">(std::string str)</span></span>;<br>    <span class="hljs-function">std::string  <span class="hljs-title">getStr</span><span class="hljs-params">()</span> </span>;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getNum</span><span class="hljs-params">()</span> </span>;<br><span class="hljs-keyword">private</span>:<br>    std::string str_;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> num; <span class="hljs-comment">// count value</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> DECLSPEC  <span class="hljs-title">print</span><span class="hljs-params">()</span></span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span> <span class="hljs-comment">//HELLO_LIB_LIBRARY_H</span></span><br></code></pre></td></tr></table></figure><p>需要额外的添加<code>__declspec(dllexport)</code>指示这个类/函数是一个可导出类或函数，以便在<code>dll</code>中导出它的接口同时在<code>lib</code>中有对应的符号信息（只有添加了它，<code>MSVC</code>才会生成必需的<code>.lib</code>导入库）。同时在使用这个库的项目中引用相关的头文件也需要添加<code>__declspec(dllimport)</code>来导入所需的数据（没有这个扩展的话，<strong>在一些场景时会出现无法解析符号的错误</strong>，比如静态数据的导出等），所以为了方便使用同一个头文件，在这里采用一个宏来标识这两者的切换时刻。（构建库时导出（<code>__declspec(dllexport)</code>），使用库时导入（<code>__declspec(dllimport)</code>））</p><p>修改<code>CMakeLists</code>文件：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.26</span>)<br><span class="hljs-keyword">project</span>(library)<br><br><span class="hljs-keyword">set</span>(CMAKE_CXX_STANDARD <span class="hljs-number">11</span>)<br><span class="hljs-comment"># SHARED 共享库</span><br><span class="hljs-keyword">add_library</span>(library SHARED library.cpp)<br><span class="hljs-comment"># 加入预定义宏 EXPORTTING</span><br><span class="hljs-keyword">add_definitions</span>(-DEXPORTTING )<br></code></pre></td></tr></table></figure><p>在对应环境下采用<code>Cmake</code>工具 构建即可得到对应环境下的动态库文件，比如<code>Windows</code>环境下会生成<code>.lib</code>文件和<code>.dll</code>文件，<code>.lib</code>直接和静态库的配置方式一样，在<code>CMakeLists</code>中修改即可，而将<code>.dll</code>文件直接放置在可执行文件同一路径下，即可隐式链接、调用。而在<code>Linux</code>环境中，只会生成一个<code>.so</code>文件，其在其他项目的<code>cmake</code>使用配置与静态库配置一致。</p><div class="note note-primary">            <p>前面提到的<code>cmake</code>工具构建，构建涉及的命令可以归纳为以下步骤：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 在项目根目录下执行</span><br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 创建build目录 并进行构建</span><br>cmake -Bbuild<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 执行 make 即可完成构建</span><br><span class="hljs-meta">#</span><span class="bash"> 方式一</span><br>cd build <br>make<br><span class="hljs-meta">#</span><span class="bash"> 方式二 build 是构建目录 lib_test 是构建目标名</span><br>cmake --build build --target lib_test -j 8<br><br></code></pre></td></tr></table></figure>          </div><h4 id="它们的不同"><a href="#它们的不同" class="headerlink" title="它们的不同"></a>它们的不同</h4><ul><li><strong>链接时刻不同</strong>：静态库会在编译期完成拷贝与链接，而动态库会在运行时按需载入。</li><li><strong>可执行文件大小不同</strong>：静态库需要整体进行拷贝成为可执行文件的一部分，而动态库无需拷贝多次（拷贝一次，而后其他程序进行共享），故对于同一个库，采用动态链接会使得体积相比静态库更小。</li><li><strong>执行速度不同</strong>：静态库在编译期间已经完成链接，而动态库则会有额外的动态载入开销，所以相对来说，静态链接库更快。</li><li><strong>库更新的影响不同</strong>：静态库因为会成为可执行文件的一部分，所以其更新的时候会导致可执行文件也需要重新编译，而动态库只需更新版本即可（接口不变）。</li></ul><h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><ul><li><a href="https://www.zhihu.com/question/20484931">Linux 中的动态链接库和静态链接库是干什么的？ - 知乎 (zhihu.com)</a></li><li><a href="https://stackoverflow.com/questions/2649334/difference-between-static-and-shared-libraries">c++ - Difference between static and shared libraries? - Stack Overflow</a></li><li><a href="http://riverj.top/index.php/archives/265/">动态库与静态库编译与使用实验 - River’s Blog (riverj.top)</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>C/C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C/C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TOTP算法实现</title>
    <link href="/2023/09/17/TOTP%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/"/>
    <url>/2023/09/17/TOTP%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<div class="note note-primary">            <p>最近发现github天天给我发通知要启用<strong>双因子认证（2FA）</strong>，受不了了只能想办法启用了。看到它支持采用基于<strong>TOTP算法</strong>的应用的认证方式，便学习了一下TOTP算法，基于该原理简单做了一个实现，并成功启用了github的双因子认证。</p>          </div><span id="more"></span><h3 id="1-什么是双因子认证（2FA）"><a href="#1-什么是双因子认证（2FA）" class="headerlink" title="1 什么是双因子认证（2FA）"></a>1 什么是双因子认证（2FA）</h3><p>双因子认证（2FA）是一种身份验证方法，要求用户提供<strong>密码和另一个认证因子</strong>或者<strong>至少提供两个认证因子（其中一个代替密码）</strong>，从而提高用户账户的安全性。传统的密码仅为一组静态信息，很容易被窃取，而导致账户被盗用，相对来说，双因子认证比传统密码还多了一个认证步骤，并且一般来说认证因子会比传统密码更难破解、获取（具有时效性），引入双因子认证虽然带来了一定复杂度，但提高了安全性。</p><p>采用双因子认证的一个成功登录的流程：</p><p><img src="./图.jpg" alt=""></p><h3 id="2-TOTP原理"><a href="#2-TOTP原理" class="headerlink" title="2 TOTP原理"></a>2 TOTP原理</h3><p><code>TOTP</code>（英文全称：Time-Based One-Time Password Algorithm） 是基于时间的一次性密码算法。该算法是在<code>HOTP</code>算法的基础上改进而来，<code>HOTP</code>是一个基于事件的OTP算法，其中的移动因子是一个<strong>事件计数器</strong>，而<code>TOTP</code>的移动因子是<strong>时间值</strong>。基于时间的变体提供了短暂的<code>OTP</code>值，有助于增强安全性。</p><h4 id="2-1-HOTP原理"><a href="#2-1-HOTP原理" class="headerlink" title="2.1 HOTP原理"></a>2.1 HOTP原理</h4><p><code>HOTP</code>是基于<code>HMAC</code>（采用加密哈希函数进行消息验证的机制）生成一次性密码值的算法。</p><p><strong>算法核心参数</strong></p><ul><li><code>C</code>：计数器（移动因子），是一个<code>8-byte</code>的值，需要在客户端与服务器之间同步</li><li><code>K</code>：密钥，在客户端与服务器之间共享，多个客户端之间的密钥<strong>应该保证不同且唯一</strong></li><li><code>T</code>：节流参数，<code>T</code>次认证不成功之后服务器将会拒绝来自客户端的请求（<strong>本文实现未用到</strong>）</li><li><code>s</code>：再同步参数，服务器将尝试通过多个连续的计数器值验证接收到的身份验证器（<strong>本文实现未用到</strong>）</li><li><code>Digit</code>：<code>HOTP</code>值位数</li></ul><p><strong>算法定义</strong></p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-variable">HOTP</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span><span class="hljs-built_in">C</span><span class="hljs-punctuation">)</span> <span class="hljs-operator">=</span> <span class="hljs-variable">Trancate</span><span class="hljs-punctuation">(</span><span class="hljs-variable">HMAC</span><span class="hljs-operator">-</span><span class="hljs-variable">SHA</span><span class="hljs-operator">-</span><span class="hljs-number">1</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span><span class="hljs-built_in">C</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">)</span><br></code></pre></td></tr></table></figure><p>其中，<code>Trancate</code>代表将<code>HMAC-SHA-1</code>值转换为<code>HOTP</code>值的函数。<code>K</code>、<code>C</code>以及数据值会首先被散列成高阶字节。<strong>而由<code>HOTP</code>生成器生成的<code>HOTP</code>值是按照大端模式进行表示的。</strong></p><p><strong>算法实现细节</strong></p><p>生成<code>HOTP</code>值主要有三个不同的步骤：</p><ol><li><code>HS=HMAC-SHA-1(K,C)</code>，采用<code>HMAC-SHA-1</code>生成一个<code>20-byte</code>大小的字符串。</li><li>截取<code>HS</code>的值(采用<code>DT</code>函数截取<code>20-byte</code>中的字串，生成<code>4-byte</code>大小的字符串)， <code>Sbits = DT(HS)</code>。</li><li>基于第二步提供的字符串，转换为一个整数，并对<code>10^Digit</code>进行取模，便能生成指定<code>Digit</code>位数的<code>HOTP</code>值了。</li></ol><p><code>DT</code>函数：<br><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">DT</span>(String) // String = String[<span class="hljs-number">0</span>]...String[<span class="hljs-number">19</span>] 即<span class="hljs-number">20</span>个字节长度的字符串（第一步由HMAC-SHA-<span class="hljs-number">1</span>所生成的）<br>    <span class="hljs-attribute">Let</span> OffsetBits be the low-order <span class="hljs-number">4</span> bits of String[<span class="hljs-number">19</span>] // 最后一个字节的低<span class="hljs-number">4</span>位取出来做为待截取字串的索引<br>    <span class="hljs-attribute">Offset</span> = StToNum(OffsetBits) // <span class="hljs-number">0</span> &lt;= OffSet &lt;= <span class="hljs-number">15</span> &lt;= <span class="hljs-number">2</span>^<span class="hljs-number">4</span> = <span class="hljs-number">16</span>，表达范围，从<span class="hljs-number">0</span>~<span class="hljs-number">15</span>处索引且取<span class="hljs-number">4</span>个字节，刚好能覆盖整个<span class="hljs-number">20</span>字节长的字符串<br>    <span class="hljs-attribute">Let</span> P = String[OffSet]...String[OffSet+<span class="hljs-number">3</span>] // 取其中四个字节<br>    <span class="hljs-attribute">Return</span> the Last <span class="hljs-number">31</span> bits of P  // 最高位被掩码去掉了是因为避免后续因求模运算所导致的有符号与无符号混淆<br></code></pre></td></tr></table></figure><br><strong>生成的<code>HOTP</code>值的最小位数为6，也可以是7或者8。</strong> 为了安全性着想，可以将其位数设置为7或者更多。</p><p><strong>一个例子</strong></p><blockquote><p>假定生成的<code>HOTP</code>值位数为<strong>6</strong>，例子所给的<code>hmac_result</code>是由<code>HMAC-SHA-1</code>生成的一个<code>20-byte</code>数组。</p></blockquote><p>DT函数的核心实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> offset   =  hmac_result[<span class="hljs-number">19</span>] &amp; <span class="hljs-number">0xf</span> ;  <span class="hljs-comment">// 获取索引 0xf -&gt; 1111</span><br><span class="hljs-keyword">int</span> bin_code = (hmac_result[offset]  &amp; <span class="hljs-number">0x7f</span>) &lt;&lt; <span class="hljs-number">24</span><br>           | (hmac_result[offset+<span class="hljs-number">1</span>] &amp; <span class="hljs-number">0xff</span>) &lt;&lt; <span class="hljs-number">16</span><br>           | (hmac_result[offset+<span class="hljs-number">2</span>] &amp; <span class="hljs-number">0xff</span>) &lt;&lt;  <span class="hljs-number">8</span><br>           | (hmac_result[offset+<span class="hljs-number">3</span>] &amp; <span class="hljs-number">0xff</span>) ; <span class="hljs-comment">// 取四个字节 并转为 整数</span><br></code></pre></td></tr></table></figure></p><p>假定<code>hmac_result</code>的内容如下：<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">-------------------------------------------------------------<br>|<span class="hljs-string"> Byte Number                                               </span>|<br>-------------------------------------------------------------<br>|<span class="hljs-string">00</span>|<span class="hljs-string">01</span>|<span class="hljs-string">02</span>|<span class="hljs-string">03</span>|<span class="hljs-string">04</span>|<span class="hljs-string">05</span>|<span class="hljs-string">06</span>|<span class="hljs-string">07</span>|<span class="hljs-string">08</span>|<span class="hljs-string">09</span>|<span class="hljs-string">10</span>|<span class="hljs-string">11</span>|<span class="hljs-string">12</span>|<span class="hljs-string">13</span>|<span class="hljs-string">14</span>|<span class="hljs-string">15</span>|<span class="hljs-string">16</span>|<span class="hljs-string">17</span>|<span class="hljs-string">18</span>|<span class="hljs-string">19</span>|<br>-------------------------------------------------------------<br>|<span class="hljs-string"> Byte Value                                                </span>|<br>-------------------------------------------------------------<br>|<span class="hljs-string">1f</span>|<span class="hljs-string">86</span>|<span class="hljs-string">98</span>|<span class="hljs-string">69</span>|<span class="hljs-string">0e</span>|<span class="hljs-string">02</span>|<span class="hljs-string">ca</span>|<span class="hljs-string">16</span>|<span class="hljs-string">61</span>|<span class="hljs-string">85</span>|<span class="hljs-string">50</span>|<span class="hljs-string">ef</span>|<span class="hljs-string">7f</span>|<span class="hljs-string">19</span>|<span class="hljs-string">da</span>|<span class="hljs-string">8e</span>|<span class="hljs-string">94</span>|<span class="hljs-string">5b</span>|<span class="hljs-string">55</span>|<span class="hljs-string">5a</span>|<br>-------------------------------<span class="hljs-symbol">*</span><span class="hljs-symbol">*</span><span class="hljs-symbol">*</span><span class="hljs-symbol">*</span><span class="hljs-symbol">*</span><span class="hljs-symbol">*</span><span class="hljs-symbol">*</span><span class="hljs-symbol">*</span><span class="hljs-symbol">*</span><span class="hljs-symbol">*</span><span class="hljs-symbol">*</span>----------------++|<br></code></pre></td></tr></table></figure></p><ul><li>最后一个字节，即<code>hmac_result[19]</code>为<code>0x5a</code>,低4位就是<code>a</code>（偏移值），那么转为十进制就是 10</li><li>从偏移值(<code>offset= 10</code>)开始取四个字节，即<code>0x50ef7f19</code></li><li>由于最高的字节<code>0x50</code>的二进制为<code>0101 0000</code>，经过<code>0x7f</code>掩码后，依然为<code>0x50</code>，故掩码处理最后依然是<code>0x50ef7f19</code>，其整数值为<code>1357872921</code></li><li>对<code>1000000</code>（6位，<code>10^6</code>）取模，最后得到的6位<code>HOTP</code>码为<code>872921</code></li></ul><p>用来自<a href="https://www.jianshu.com/p/a7b900e8e50a">HOTP和TOTP算法图解</a>文章的图来描述该流程：<br><img src="./algorthm-process.png" alt=""></p><h4 id="2-2-TOTP"><a href="#2-2-TOTP" class="headerlink" title="2.2 TOTP"></a>2.2 TOTP</h4><p>TOTP算法是<code>HOTP</code>算法基于时间的变体，其中<code>T</code>（从时间戳和步长中导出）将会代替公式中的<code>C</code>。同时，<code>TOTP</code>可以使用<code>HMAC-SHA-256</code>或者<code>HMAC-SHA-512</code>函数，而不再局限于<code>HMAC-SHA-1</code>。</p><p><strong>算法要求</strong></p><ul><li>客户端与服务器必须能够获取当前的<code>Unix</code>时间（自1970年1月1日午夜（UTC）以来经过的秒数）</li><li>客户端与服务器必须共享同一个密钥或者生成共享秘密的秘密转换知识</li><li>算法必须采用<code>HOTP</code>算法作为关键构建块</li><li>客户端和服务器必须使用同样的时间步长<code>X</code></li><li>在每一个客户端中，密钥必须是唯一的</li><li>密钥应该使用密钥派生算法随机生成或派生</li><li><p>密钥可以存储在防篡改设备中，并且应该受到保护，防止未经授权的访问和使用。</p><blockquote><p>上述提到的客户端和服务器，可以分别理解为一个生成<code>TOTP</code>码的应用或者是程序，而服务器可以理解成校验器、验证器。</p></blockquote></li></ul><p><strong>核心参数</strong></p><ul><li><code>X</code>：时间步长（秒），默认是<code>30</code></li><li><code>T0</code>：开始计算时间步长的<code>Unix</code>时间，默认是0</li></ul><p><strong>算法细节</strong></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">TOTP</span> = HOTP(K,T)<br></code></pre></td></tr></table></figure><p>其中<code>T=(current Unix Time - T0)/X</code>, <code>T</code>是一个整数，该计算采用下限函数。</p><p>依然采用来自<a href="https://www.jianshu.com/p/a7b900e8e50a">HOTP和TOTP算法图解</a>文章的图来描述该流程：</p><p><img src="./TOPT_Algorithm.png" alt=""></p><p>该算法与<code>HOTP</code>算法剩余流程一致。</p><h3 id="3-实现"><a href="#3-实现" class="headerlink" title="3 实现"></a>3 实现</h3><p>笔者采用<code>C++</code>并结合<code>Crypto++</code>库进行实现，具体源代码详见<a href="https://github.com/1291945816/hybrid-repo/tree/main/ToTpAuth">ToTpAuth</a>,代码量不多。其中部分实现细节，参考了python中的<a href="https://pyauth.github.io/pyotp/">PyOTP库源码</a>。</p><blockquote><p>相对来说，采用<code>C++</code>工作量相比<code>Java</code>、<code>Python</code>更多一些。如果不想实现，可以直接用PyOTP库来写个简单的脚本生成<code>TOTP</code>码即可。</p></blockquote><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ul><li><a href="https://datatracker.ietf.org/doc/html/rfc4226">RFC4226</a></li><li><a href="https://datatracker.ietf.org/doc/html/rfc6238">RFC6238</a></li><li><a href="https://zhaoyang.me/posts/totp-algorithm/">动态密码TOTP</a></li><li><a href="https://notes.mengxin.science/2017/05/30/hotp-totp-algorithm-analysis/">HOTP和TOTP算法图解</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>C/C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C/C++</tag>
      
      <tag>TOTP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>初识FUSE（Filesystem in userspace）</title>
    <link href="/2023/09/13/%E5%88%9D%E8%AF%86FUSE%EF%BC%88Filesystem-in-userspace%EF%BC%89/"/>
    <url>/2023/09/13/%E5%88%9D%E8%AF%86FUSE%EF%BC%88Filesystem-in-userspace%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<div class="note note-primary">            <p>之前因为一次作业有幸接触过<code>FUSE</code>,觉得它是一个很不错的框架，没来得及仔细了解。现在有点时间了，想要利用它做一个文件系统，便系统地去学习一下，在这里简单做个总结。</p>          </div><span id="more"></span><h4 id="什么是FUSE？"><a href="#什么是FUSE？" class="headerlink" title="什么是FUSE？"></a>什么是FUSE？</h4><blockquote><p><strong>FUSE is a userspace filesystem framework</strong>. </p></blockquote><p>FUSE（全称Filesystem In Userspace）是一个<strong>用户空间的文件系统框架</strong>，也就是说能够允许用户在用户空间创建并管理文件系统。它由三部分组件组成：</p><ul><li>内核模块（<code>fuse.ko</code>）：协议封装和解析，封装转发由<code>VFS</code>转发过来的请求给用户态程序</li><li>用户空间库（<code>libfuse.*</code>）：协议解析和封装，负责解析由内核模块封装好的<code>IO</code>请求</li><li>挂载工具（<code>fusemount</code>）：用户态文件系统挂载</li></ul><p>用户态文件系统是区别于内核文件系统的，在用户态文件系统没有出现之前，常见的文件系统如<code>Ext2</code>、<code>Ext4</code>等都是在内核中直接实现的，这就很容易引发一个问题：（开发角度）<strong>调试困难</strong>；（使用角度）<strong>需要提权（root）</strong>。而用户态文件系统框架FUSE提供了这样一个机会：能<strong>保证安全</strong>且<strong>不需要提权</strong>，开发过程中也<strong>易调试</strong>。但需要考虑到的是：FUSE作为一层框架，相当于在原有的文件系统上套了一层代理，相比原来内核实现的文件系统，会带来更多的性能开销。</p><h4 id="FUSE原理"><a href="#FUSE原理" class="headerlink" title="FUSE原理"></a>FUSE原理</h4><p>FUSE的工作流程可以用下图表示：</p><p><img src="FUSE.jpg" alt="FUSE"></p><p>从图中可以看到，当用户空间发起<code>request(ls -l /tmp/fuse)</code>时，首先<code>VFS</code>获得请求（经由<strong>系统调用</strong>，再根据<strong>挂载点</strong>分析文件系统）并转发到内核模块中的<code>FUSE</code>，该框架按照预先定义好的<strong>协议</strong>将请求进行封装，并将封装好的请求发送给<strong>处理程序</strong>，而处理程序会解析该请求为原始请求并完成对应处理（利用<code>libfuse</code>），再按原路返回，由<code>VFS</code>将数据进行返回给用户空间。</p><p>在这里有一个注意的点：处理程序是如何和<code>FUSE</code>传输数据的？是<code>/dev/fuse</code>虚拟块设备，当<code>FUSE</code>将请求打包成特定格式后，会将数据放置于<code>/dev/fuse</code>中，而<strong>守护进程（在用户空间侧）</strong>监听到有消息后会立即读取来处理。</p><h5 id="FUSE协议"><a href="#FUSE协议" class="headerlink" title="FUSE协议"></a>FUSE协议</h5><p>在<code>struct fuse_req</code>（向客户端发出的请求）的源码可以找到两个请求头<code>struct fuse_in_header</code>和<code>struct fuse_out_header</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fuse_req</span> &#123;</span><br>    ......<br><span class="hljs-comment">/* The request input header */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fuse_in_header</span> <span class="hljs-title">h</span>;</span><br>&#125; in;<br><br><span class="hljs-comment">/* The request output header */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fuse_out_header</span> <span class="hljs-title">h</span>;</span><br>&#125; out;<br>    ......<br>&#125;<br></code></pre></td></tr></table></figure><p><code>struct fuse_in_header</code>的定义（内核中、<code>libfuse</code>中均有定义）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fuse_in_header</span> &#123;</span><br><span class="hljs-keyword">uint32_t</span>len; <span class="hljs-comment">//数据长度</span><br><span class="hljs-keyword">uint32_t</span>opcode; <span class="hljs-comment">// 操作码</span><br><span class="hljs-keyword">uint64_t</span>unique; <span class="hljs-comment">// 唯一请求id</span><br><span class="hljs-keyword">uint64_t</span>nodeid; <span class="hljs-comment">// 被操作的文件系统对象（文件/目录）的ID</span><br><span class="hljs-keyword">uint32_t</span>uid; <span class="hljs-comment">// 请求进程的uid</span><br><span class="hljs-keyword">uint32_t</span>gid; <span class="hljs-comment">// 请求进程的gid</span><br><span class="hljs-keyword">uint32_t</span>pid; <span class="hljs-comment">//请求进程的pid</span><br><span class="hljs-keyword">uint16_t</span>total_extlen; <span class="hljs-comment">/* 在libfuse中额外的定义*/</span><br><span class="hljs-keyword">uint16_t</span>padding; <br>&#125;;<br></code></pre></td></tr></table></figure><p>在请求头之后一般会紧接着一个<strong>请求体</strong>，类似于<code>http</code>协议，而请求体的大小是可变的（这跟发出请求后携带的实际数据大小有关的，可以通过<code>opcode</code>操作码来进行判断）</p><p><code>struct fuse_out_header</code>的定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fuse_out_header</span> &#123;</span><br><span class="hljs-keyword">uint32_t</span>len;  <span class="hljs-comment">//数据长度</span><br><span class="hljs-keyword">int32_t</span>error; <span class="hljs-comment">// 错误码</span><br><span class="hljs-keyword">uint64_t</span>unique; <span class="hljs-comment">// 唯一请求id</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>这个响应头也是类似于请求头，当<strong>处理程序</strong>完成对请求头的处理后，会根据协议将结果进行封装传回内核中，这就会用到响应头（如果携带有响应数据的话还会包含一个响应体）。在这个过程中，内核是通过<code>unique</code>标识请求的。</p><h4 id="如何去使用？"><a href="#如何去使用？" class="headerlink" title="如何去使用？"></a>如何去使用？</h4><p>在<code>libfuse</code>的官方开源代码介绍中提到了这个库提供了两种<code>API</code>:</p><ul><li><code>high-level</code>：同步<code>API</code>,处理工作主要是与文件名称<code>file name</code>，文件路径<code>path</code>处理相关，并且当回调函数返回时请求处理完成。</li><li><code>low-level</code>：异步<code>API</code>,所处理的必须是跟索引节点<code>inode</code>相关（相对来说要更加地熟悉底层文件系统实现的细节），响应必须使用一组单独的API函数显示发送。</li></ul><p>具体如何使用，请查阅源码中所提供的<a href="https://github.com/libfuse/libfuse/tree/master/example">例子</a>。</p><h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><ul><li><p><a href="https://fishpi.cn/article/1640420458343">详解 FUSE 用户态文件系统 - 摸鱼派 (fishpi.cn)</a></p></li><li><p><a href="https://www.a-programmer.top/2021/10/05/FUSE介绍/">FUSE介绍 | 成长录-知行合一 (a-programmer.top)</a></p></li><li><p><a href="https://www.jianshu.com/p/c2b77d0bbc43">FUSE(Filesystem in Userspace) - 简书 (jianshu.com)</a></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>filesystem</tag>
      
      <tag>FUSE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux中的虚拟文件系统（virtual file system）</title>
    <link href="/2023/09/11/Linux%E4%B8%AD%E7%9A%84%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%EF%BC%88virtual-file-system%EF%BC%89/"/>
    <url>/2023/09/11/Linux%E4%B8%AD%E7%9A%84%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%EF%BC%88virtual-file-system%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<div class="note note-primary">            <p>要回答为何Linux系统能够支持多种不同类型的文件系统？是怎么做到的？这就得研究一下Linux中的虚拟文件系统（简写为<code>VFS</code>），才能给出答案了。</p>          </div><span id="more"></span><p><strong>虚拟文件系统（VFS）</strong>是一个处于内核中的软件层，它的作用为：</p><ul><li>对于用户空间的程序来说，提供文件系统接口；</li><li>对于文件系统来说，提供一个统一抽象，由具体文件系统来实现细节。</li></ul><p><img src="VFS.jpg" alt="VFS"></p><blockquote><p>类似于面向对象思想中的<strong>接口</strong>，规范是已经统一的，而如何去实现规范就看各文件系统如何操作了。</p></blockquote><h3 id="1-VFS中的基本抽象数据结构"><a href="#1-VFS中的基本抽象数据结构" class="headerlink" title="1 VFS中的基本抽象数据结构"></a>1 VFS中的基本抽象数据结构</h3><blockquote><p>了解一个具体的模块，首先要从它实现的数据结构出发，理解了才能更好地解析其调用过程。</p></blockquote><p><code>VFS</code>核心的四个数据结构为：</p><ul><li><code>super_block</code> ：<em>超级块</em>，用于描述具体的文件系统信息</li><li><code>inode</code>：<em>索引节点</em>，用以描述一个文件的元信息，如文件大小、权限、拥有者等，每个文件均对应一个<code>inode</code></li><li><code>dentry</code>：<em>目录项结构</em>，它的出现就是为了性能，一般在磁盘中是没有对应的结构的</li><li><code>file</code>：<code>文件结构</code>，代表与进程交互过程中被打开的一个文件</li></ul><h4 id="1-1-超级块"><a href="#1-1-超级块" class="headerlink" title="1.1 超级块"></a>1.1 超级块</h4><p>一个具体的文件系统，如<code>ext2</code>、<code>ext4</code>等，都会对应一个超级块结构。内核也是通过扫描这个结构的信息来确定文件系统的大致信息，以下为其在内核源码中的部分定义（选自<code>Linux 5.19</code>，后续一样）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">super_block</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span><span class="hljs-title">s_list</span>;</span><span class="hljs-comment">// 指向超级块链表的指针</span><br><span class="hljs-keyword">dev_t</span>s_dev;<span class="hljs-comment">/* 块设备的具体标识号 */</span><br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>s_blocksize_bits;<br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>s_blocksize; <span class="hljs-comment">// 文件系统中的数据块大小</span><br><span class="hljs-keyword">loff_t</span>s_maxbytes;<span class="hljs-comment">/* 允许的最大文件的大小 */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_system_type</span>*<span class="hljs-title">s_type</span>;</span> <span class="hljs-comment">// 具体的文件系统类型</span><br><span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">super_operations</span>*<span class="hljs-title">s_op</span>;</span> <span class="hljs-comment">// 用于超级块操作的函数集合</span><br><span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">quotactl_ops</span>*<span class="hljs-title">s_qcop</span>;</span> <span class="hljs-comment">// 限额操作的函数集合</span><br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>s_flags; <span class="hljs-comment">// 安装表示</span><br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>s_magic; <span class="hljs-comment">// 幻数 一般可以用于表示唯一的文件系统</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dentry</span>*<span class="hljs-title">s_root</span>;</span> <span class="hljs-comment">//根dentry</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rw_semaphore</span><span class="hljs-title">s_umount</span>;</span> <span class="hljs-comment">// 同步读写</span><br><span class="hljs-keyword">int</span>s_count; <span class="hljs-comment">// 超级块的使用计数</span><br><span class="hljs-keyword">atomic_t</span>s_active;<br><span class="hljs-keyword">void</span>*s_fs_info;<span class="hljs-comment">/* 文件系统的隐私信息 */</span><br><span class="hljs-comment">/* c/m/atime限制 */</span><br><span class="hljs-keyword">time64_t</span>   s_time_min;<br><span class="hljs-keyword">time64_t</span>   s_time_max;<br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>s_max_links;<br><span class="hljs-keyword">fmode_t</span>s_mode;<br>    <span class="hljs-comment">// 默认的目录项操作集合</span><br><span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dentry_operations</span> *<span class="hljs-title">s_d_op</span>;</span> <span class="hljs-comment">/* default d_op for dentries */</span><br>    <span class="hljs-comment">// 虽然链接数目为0 但仍然被引用</span><br><span class="hljs-keyword">atomic_long_t</span> s_remove_count;<br>    <span class="hljs-comment">// 没有被使用的dentry、inode会被加入这个</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_lru</span><span class="hljs-title">s_dentry_lru</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_lru</span><span class="hljs-title">s_inode_lru</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rcu_head</span><span class="hljs-title">rcu</span>;</span><br><span class="hljs-comment">/* s_inode_list_lock protects s_inodes */</span><br><span class="hljs-keyword">spinlock_t</span>s_inode_list_lock ____cacheline_aligned_in_smp;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span><span class="hljs-title">s_inodes</span>;</span><span class="hljs-comment">/* 所有的索引节点 由前面的锁进行保护 */</span><br><br><span class="hljs-keyword">spinlock_t</span>s_inode_wblist_lock;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span><span class="hljs-title">s_inodes_wb</span>;</span><span class="hljs-comment">/* writeback inodes */</span><br>    ......<br>&#125; __randomize_layout;<br></code></pre></td></tr></table></figure><p>超级块的操作函数集合：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">super_operations</span> &#123;</span><br>    <span class="hljs-comment">//给超级块分配索引节点</span><br>   <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> *(*<span class="hljs-title">alloc_inode</span>)(<span class="hljs-keyword">struct</span> <span class="hljs-title">super_block</span> *<span class="hljs-title">sb</span>);</span> <br>    <span class="hljs-comment">// 销毁索引节点</span><br><span class="hljs-keyword">void</span> (*destroy_inode)(struct inode *);<br><span class="hljs-comment">// 检查atime的更新情况</span><br>   <span class="hljs-keyword">void</span> (*dirty_inode) (struct inode *, <span class="hljs-keyword">int</span> flags);<br>    <span class="hljs-comment">// 写入一个inode到磁盘中</span><br><span class="hljs-keyword">int</span> (*write_inode) (struct inode *, struct writeback_control *wbc);<br>    <span class="hljs-comment">// 删除一个inode</span><br><span class="hljs-keyword">int</span> (*drop_inode) (struct inode *);<br>    <span class="hljs-comment">//在链接数目为0时会进行释放</span><br><span class="hljs-keyword">void</span> (*evict_inode) (struct inode *);<br>    <span class="hljs-comment">// 释放超级块所占用的内存</span><br><span class="hljs-keyword">void</span> (*put_super) (struct super_block *);<br>    ......<br>&#125;;<br></code></pre></td></tr></table></figure><p>这些集合的函数会由<strong>具体的文件系统</strong>进行实现，没有实现的会被置为<code>NULL</code></p><h4 id="1-2-索引节点"><a href="#1-2-索引节点" class="headerlink" title="1.2 索引节点"></a>1.2 索引节点</h4><p>Linux中是<strong>视一切为文件</strong>，一个文件就会有对应的<code>inode</code>，文件包含了常规文件、目录等。在需要时，在磁盘中的<code>inode</code>会被拷贝到内存中，修改完毕后会被写回到磁盘中。一个<code>inode</code>会被指向多个目录项索引（硬链接等）</p><p>以下为它在内核中的部分源码定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> &#123;</span><br><span class="hljs-keyword">umode_t</span>i_mode; <br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span>i_opflags;<br><span class="hljs-keyword">kuid_t</span>i_uid; <span class="hljs-comment">// 文件所属的用户</span><br><span class="hljs-keyword">kgid_t</span>i_gid; <span class="hljs-comment">// 文件所属的组</span><br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>i_flags;<br><br><br><span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode_operations</span>*<span class="hljs-title">i_op</span>;</span> <span class="hljs-comment">// 索引节点操作函数集</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">super_block</span>*<span class="hljs-title">i_sb</span>;</span> <span class="hljs-comment">// 文件所在文件系统的超级块</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">address_space</span>*<span class="hljs-title">i_mapping</span>;</span><br><br><br><span class="hljs-comment">/* Stat data, not accessed from path walking */</span><br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>i_ino; <span class="hljs-comment">// 索引号</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Filesystems may only read i_nlink directly.  They shall use the</span><br><span class="hljs-comment"> * following functions for modification:</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *    (set|clear|inc|drop)_nlink</span><br><span class="hljs-comment"> *    inode_(inc|dec)_link_count</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> i_nlink; <span class="hljs-comment">// 链接数目</span><br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> __i_nlink;<br>&#125;;<br><span class="hljs-keyword">dev_t</span>i_rdev; <span class="hljs-comment">// 文件所在的设备号</span><br><span class="hljs-keyword">loff_t</span>i_size; <span class="hljs-comment">// 文件大小</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timespec64</span><span class="hljs-title">i_atime</span>;</span><span class="hljs-comment">// 最后的访问时间</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timespec64</span><span class="hljs-title">i_mtime</span>;</span> <span class="hljs-comment">// 最后修改时间</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timespec64</span><span class="hljs-title">i_ctime</span>;</span> <span class="hljs-comment">// 最后改变时间</span><br><span class="hljs-keyword">spinlock_t</span>i_lock;<span class="hljs-comment">/* i_blocks, i_bytes, maybe i_size */</span><br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span>          i_bytes; <span class="hljs-comment">// 使用的字节数</span><br><br><span class="hljs-comment">/* Misc */</span><br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>i_state;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rw_semaphore</span><span class="hljs-title">i_rwsem</span>;</span> <span class="hljs-comment">// 读写信号量</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hlist_node</span><span class="hljs-title">i_hash</span>;</span> <span class="hljs-comment">// 哈希值 负责提高查找效率</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span><span class="hljs-title">i_io_list</span>;</span><span class="hljs-comment">/* backing dev IO list */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span><span class="hljs-title">i_lru</span>;</span><span class="hljs-comment">/* inode LRU list  未使用的inode*/</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span><span class="hljs-title">i_sb_list</span>;</span> <span class="hljs-comment">// 链接一个文件系统中的inode链表</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span><span class="hljs-title">i_wb_list</span>;</span><span class="hljs-comment">/* backing dev writeback list */</span><br><span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hlist_head</span><span class="hljs-title">i_dentry</span>;</span> <span class="hljs-comment">// 所属的目录项</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rcu_head</span><span class="hljs-title">i_rcu</span>;</span><br>&#125;;<br><span class="hljs-keyword">atomic64_t</span>i_version; <span class="hljs-comment">// 索引节点版本号</span><br><span class="hljs-keyword">atomic_t</span>i_count; <span class="hljs-comment">// 引用计数</span><br><span class="hljs-keyword">atomic_t</span>i_writecount; <span class="hljs-comment">// 写计数</span><br>    <span class="hljs-comment">// 文件操作函数集合</span><br><span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br><span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span>*<span class="hljs-title">i_fop</span>;</span><span class="hljs-comment">/* former -&gt;i_op-&gt;default_file_ops */</span><br><span class="hljs-keyword">void</span> (*free_inode)(struct inode *);<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">address_space</span><span class="hljs-title">i_data</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span><span class="hljs-title">i_devices</span>;</span><br><span class="hljs-keyword">void</span>*i_private; <span class="hljs-comment">/* 文件与设备的私有指针 */</span><br>    ......<br>&#125; __randomize_layout;<br></code></pre></td></tr></table></figure><p>索引节点的函数操作集合：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode_operations</span> &#123;</span><br>    <span class="hljs-comment">// 查找指定文件的dentry</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dentry</span> * (*<span class="hljs-title">lookup</span>) (<span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> *,<span class="hljs-keyword">struct</span> <span class="hljs-title">dentry</span> *, <span class="hljs-title">unsigned</span> <span class="hljs-title">int</span>);</span><br><span class="hljs-comment">//根据inode所描述的文件类型，如果是目录，则会创建一个inode，不是则不会调用</span><br><span class="hljs-keyword">int</span> (*create) (struct user_namespace *, struct inode *,struct dentry *,<br>       <span class="hljs-keyword">umode_t</span>, <span class="hljs-keyword">bool</span>);<br>    <span class="hljs-comment">//在指定目录下创建一个子目录</span><br><span class="hljs-keyword">int</span> (*mkdir) (struct user_namespace *, struct inode *,struct dentry *,<br>      <span class="hljs-keyword">umode_t</span>);<br>    <span class="hljs-comment">//从inode所描述的目录中删除一个子目录时，会被调用</span><br><span class="hljs-keyword">int</span> (*rmdir) (struct inode *,struct dentry *);<br>    ......<br>&#125; ____cacheline_aligned;<br></code></pre></td></tr></table></figure><h4 id="1-3-目录项结构"><a href="#1-3-目录项结构" class="headerlink" title="1.3 目录项结构"></a>1.3 目录项结构</h4><p>它的出现主要是<strong>为了查找性能</strong>，只存在于内存中，而不存在于磁盘中。<u>这提供了一种非常快的查询机制来将一个路径名称（文件名称）转换为特定的目录项对象。</u></p><p>以下为它在内核中的部分源码定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dentry</span> &#123;</span><br><span class="hljs-comment">/* RCU lookup touched fields */</span><br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> d_flags;<span class="hljs-comment">/* protected by d_lock */</span><br><span class="hljs-keyword">seqcount_spinlock_t</span> d_seq;<span class="hljs-comment">/* per dentry seqlock */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hlist_bl_node</span> <span class="hljs-title">d_hash</span>;</span><span class="hljs-comment">/* lookup hash list 哈希列表*/</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dentry</span> *<span class="hljs-title">d_parent</span>;</span><span class="hljs-comment">/* parent directory 父目录 */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">qstr</span> <span class="hljs-title">d_name</span>;</span> <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> *<span class="hljs-title">d_inode</span>;</span><span class="hljs-comment">/*与目录关联的inode Where the name belongs to - NULL is</span><br><span class="hljs-comment"> * negative */</span><br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> d_iname[DNAME_INLINE_LEN];<span class="hljs-comment">/* small names */</span><br><br><span class="hljs-comment">/* Ref lookup also touches following */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">lockref</span> <span class="hljs-title">d_lockref</span>;</span><span class="hljs-comment">/* per-dentry lock and refcount */</span><br><span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dentry_operations</span> *<span class="hljs-title">d_op</span>;</span> <span class="hljs-comment">// 目录项操作</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">super_block</span> *<span class="hljs-title">d_sb</span>;</span><span class="hljs-comment">/* 目录项所属文件系统的超级块 The root of the dentry tree */</span><br><br><br><span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">d_lru</span>;</span><span class="hljs-comment">/* LRU list 未使用目录项以LRU算法链接的链表*/</span><br><span class="hljs-keyword">wait_queue_head_t</span> *d_wait;<span class="hljs-comment">/* in-lookup ones only */</span><br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">d_child</span>;</span><span class="hljs-comment">/* child of parent list 加入到父目录的d_subdirs */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">d_subdirs</span>;</span><span class="hljs-comment">/* our children 子目录 */</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * d_alias and d_rcu can share memory</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hlist_node</span> <span class="hljs-title">d_alias</span>;</span><span class="hljs-comment">/* inode alias list */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hlist_bl_node</span> <span class="hljs-title">d_in_lookup_hash</span>;</span><span class="hljs-comment">/* only for in-lookup ones */</span><br> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rcu_head</span> <span class="hljs-title">d_rcu</span>;</span><br>&#125; d_u;<br>&#125; __randomize_layout;<br></code></pre></td></tr></table></figure><p>目录项的函数操作集合：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dentry_operations</span> &#123;</span><br>    <span class="hljs-comment">// 检查当前目录项是否还有效</span><br><span class="hljs-keyword">int</span> (*d_revalidate)(struct dentry *, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>);<br>    <span class="hljs-comment">// 较弱形式的校验</span><br><span class="hljs-keyword">int</span> (*d_weak_revalidate)(struct dentry *, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>);<br>    <span class="hljs-comment">// </span><br><span class="hljs-keyword">int</span> (*d_hash)(<span class="hljs-keyword">const</span> struct dentry *, struct qstr *);<br>    <span class="hljs-comment">// 引用计数为0时删除dentry（dput调用）</span><br><span class="hljs-keyword">int</span> (*d_delete)(<span class="hljs-keyword">const</span> struct dentry *);<br>    <span class="hljs-comment">// 释放所占有的数据</span><br><span class="hljs-keyword">void</span> (*d_release)(struct dentry *);<br>    <span class="hljs-comment">//当dentry失去inode时调用，</span><br><span class="hljs-keyword">void</span> (*d_iput)(struct dentry *, struct inode *);<br>......<br>&#125; ____cacheline_aligned;<br></code></pre></td></tr></table></figure><h4 id="1-4-文件结构"><a href="#1-4-文件结构" class="headerlink" title="1.4 文件结构"></a>1.4 文件结构</h4><p><strong>当一个进程打开一个文件时，该文件就是用此文件结构进行描述的</strong>，如文件的读写模式、读写偏移量、所属inode等信息。这个文件结构会被进程的文件描述符表所存放。</p><p>以下为它在内核中的部分源码定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">llist_node</span><span class="hljs-title">fu_llist</span>;</span> <span class="hljs-comment">// 文件系统中被打开的文件对象（单个进程所打开的文件会被维护在另一个结构中 files_struct）</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rcu_head</span> <span class="hljs-title">fu_rcuhead</span>;</span> <br>&#125; f_u;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">path</span><span class="hljs-title">f_path</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span>*<span class="hljs-title">f_inode</span>;</span><span class="hljs-comment">/* cached value  被缓存的值 所属的inode吧*/</span><br><span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span>*<span class="hljs-title">f_op</span>;</span> <span class="hljs-comment">// 文件操作指针</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Protects f_ep, f_flags.</span><br><span class="hljs-comment"> * Must not be taken from IRQ context.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">spinlock_t</span>f_lock;    <span class="hljs-comment">// 自旋锁</span><br><span class="hljs-keyword">atomic_long_t</span>f_count; <span class="hljs-comment">// 引用计数器</span><br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> f_flags; <span class="hljs-comment">// 打开文件所引用的标志</span><br><span class="hljs-keyword">fmode_t</span>f_mode;  <span class="hljs-comment">// 文件的访问模式（r模式等）</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mutex</span><span class="hljs-title">f_pos_lock</span>;</span><br><span class="hljs-keyword">loff_t</span>f_pos; <span class="hljs-comment">// 读写偏移量</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fown_struct</span><span class="hljs-title">f_owner</span>;</span> <span class="hljs-comment">// 所属者信息</span><br><br>u64f_version; <span class="hljs-comment">// 版本号</span><br><br><span class="hljs-comment">/* needed for tty driver, and maybe others */</span><br><span class="hljs-keyword">void</span>*private_data;          <span class="hljs-comment">//隐私数据</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">address_space</span>*<span class="hljs-title">f_mapping</span>;</span><br><br>&#125; __randomize_layout<br>  __attribute__((aligned(<span class="hljs-number">4</span>)));<span class="hljs-comment">/* lest something weird decides that 2 is OK */</span><br></code></pre></td></tr></table></figure><p>文件结构的函数操作集合：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> &#123;</span><br>.......<br>    <span class="hljs-comment">// 移动文件指针</span><br><span class="hljs-keyword">loff_t</span> (*llseek) (struct file *, <span class="hljs-keyword">loff_t</span>, <span class="hljs-keyword">int</span>);<br>    <span class="hljs-comment">// 从文件对象中读数据（系统调用中的读最终会被应用于此）</span><br><span class="hljs-keyword">ssize_t</span> (*read) (struct file *, <span class="hljs-keyword">char</span> __user *, <span class="hljs-keyword">size_t</span>, <span class="hljs-keyword">loff_t</span> *);<br>    <span class="hljs-comment">// 从文件对象中写数据</span><br><span class="hljs-keyword">ssize_t</span> (*write) (struct file *, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> __user *, <span class="hljs-keyword">size_t</span>, <span class="hljs-keyword">loff_t</span> *);<br>    ......<br>&#125; __randomize_layout;<br></code></pre></td></tr></table></figure><h4 id="1-5-它们的关系"><a href="#1-5-它们的关系" class="headerlink" title="1.5 它们的关系"></a>1.5 它们的关系</h4><blockquote><p>很早就查过<code>dentry</code>、<code>inode</code>之间的关系了，但是过了一段时间还是会忘记它们之间的关系，这实际反映了这些关系并不是那么好去去理解的，那么在这里我就通过一张图来描述它们之间的关系。</p></blockquote><p><img src="image-20230910215648282.png" alt="image-20230910215648282" style="zoom: 67%;" /></p><p>在这张图中，需要额外的关注的是，<code>inode</code>、<code>dentry</code>、<code>super_block</code>之间是有链接关系的，而<code>file</code>并不需要跟它们之间存在链接关系的（不同的<code>Linux</code>的大版本会存在部分不同），构建<code>file</code>的方式是通过解析路径而从获得<code>dentry</code>、<code>inode</code>然后再用这些数据初始化它，具体细节可以分析文件的打开流程。</p><blockquote><p>这个关系也是比较简单的，实际上<code>inode</code>可能会被多个<code>dentry</code>所指向。</p></blockquote><h3 id="2-文件系统的注册与注销"><a href="#2-文件系统的注册与注销" class="headerlink" title="2 文件系统的注册与注销"></a>2 文件系统的注册与注销</h3><p><strong>注册</strong></p><p>前面说到<code>VFS</code>提供了统一的抽象接口供给具体的文件系统去实现，为了让<code>Linux</code>内核去发现真实的文件系统，那么就需要使用<code>register_filesystem</code>去注册。该函数的实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">register_filesystem</span><span class="hljs-params">(struct file_system_type * fs)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_system_type</span> ** <span class="hljs-title">p</span>;</span><br><br><span class="hljs-keyword">if</span> (fs-&gt;parameters &amp;&amp;<br>    !fs_validate_description(fs-&gt;name, fs-&gt;parameters)) <span class="hljs-comment">// 文件系统校验</span><br><span class="hljs-keyword">return</span> -EINVAL;<br><br>BUG_ON(<span class="hljs-built_in">strchr</span>(fs-&gt;name, <span class="hljs-string">&#x27;.&#x27;</span>));<br><span class="hljs-keyword">if</span> (fs-&gt;next)<br><span class="hljs-keyword">return</span> -EBUSY;<br><span class="hljs-comment">// 保护资源</span><br>write_lock(&amp;file_systems_lock);<br>p = find_filesystem(fs-&gt;name, <span class="hljs-built_in">strlen</span>(fs-&gt;name)); <span class="hljs-comment">// 遍历已经注册的文件系统</span><br><span class="hljs-keyword">if</span> (*p) <span class="hljs-comment">//已经注册 </span><br>res = -EBUSY;<br><span class="hljs-keyword">else</span><span class="hljs-comment">// 为NULL</span><br>*p = fs;<br>write_unlock(&amp;file_systems_lock);<br><span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个函数的实现思想也是很简单的，相当于是将当前<code>fs</code>加入到<strong>全局链表</strong>中，这样当Linux启动时，会遍历所有注册过的文件系统来识别磁盘中的文件系统（根据超级块<code>super_block</code>的信息）。</p><p>从函数参数可以看到，这个参数类型是<code>struct file_system_type</code>，所有具体的文件系统都需要定义一个这样的实体,它的类型定义为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_system_type</span> &#123;</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name;  <span class="hljs-comment">// 文件系统名称</span><br><span class="hljs-keyword">int</span> fs_flags; <span class="hljs-comment">// 标志</span><br><span class="hljs-keyword">int</span> (*init_fs_context)(struct fs_context *); <span class="hljs-comment">// 文件系统上下文</span><br><span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fs_parameter_spec</span> *<span class="hljs-title">parameters</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dentry</span> *(*<span class="hljs-title">mount</span>) (<span class="hljs-keyword">struct</span> <span class="hljs-title">file_system_type</span> *, <span class="hljs-title">int</span>,</span><br><span class="hljs-class">       <span class="hljs-title">const</span> <span class="hljs-title">char</span> *, <span class="hljs-title">void</span> *);</span> <span class="hljs-comment">// 挂载</span><br><span class="hljs-keyword">void</span> (*kill_sb) (struct super_block *);<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">module</span> *<span class="hljs-title">owner</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_system_type</span> * <span class="hljs-title">next</span>;</span> <span class="hljs-comment">// 指向下一个</span><br>    ......<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>注销</strong></p><p>注销这个文件系统也是相当于直接从文件系统全局列表中进行移除即可。它的函数实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">unregister_filesystem</span><span class="hljs-params">(struct file_system_type * fs)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_system_type</span> ** <span class="hljs-title">tmp</span>;</span> <br>write_lock(&amp;file_systems_lock);<br>tmp = &amp;file_systems;<br><span class="hljs-keyword">while</span> (*tmp) &#123;<br><span class="hljs-keyword">if</span> (fs == *tmp) &#123;<br>*tmp = fs-&gt;next;<br>fs-&gt;next = <span class="hljs-literal">NULL</span>;<br>write_unlock(&amp;file_systems_lock);<br>synchronize_rcu(); <span class="hljs-comment">// 阻塞更新</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>tmp = &amp;(*tmp)-&gt;next;<br>&#125;<br>write_unlock(&amp;file_systems_lock);<br><span class="hljs-keyword">return</span> -EINVAL;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3 总结"></a>3 总结</h3><p>本文从比较简单的角度学习了<code>Linux</code>内核中虚拟文件系统的源码以及其核心数据结构，<strong>如果要继续剖析该模块的内容，其实还可以更深入，如发生系统调用（如<code>read</code>、<code>write</code>等）过程中<code>VFS</code>在此过程中如何处理的。</strong> 但理解这些深入的内容，还是回归基础，搞清楚这个基本的数据结构的定义以及它们背后隐含的关系，才能更好地去分析。</p><p><strong>后续如果来得及的话，会继续分析这部分的内容</strong></p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ul><li><p><a href="https://github.com/liexusong/linux-source-code-analyze/blob/master/virtual_file_system.md">linux-source-code-analyze/virtual_file_system.md at master · liexusong/linux-source-code-analyze (github.com)</a></p></li><li><p>《深入理解Linux内核》</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>VFS</tag>
      
      <tag>filesystem</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++中的Pimpl和RAII惯用法</title>
    <link href="/2023/08/27/C++%E4%B8%AD%E7%9A%84Pimpl%E5%92%8CRAII%E6%83%AF%E7%94%A8%E6%B3%95/"/>
    <url>/2023/08/27/C++%E4%B8%AD%E7%9A%84Pimpl%E5%92%8CRAII%E6%83%AF%E7%94%A8%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<div class="note note-primary">            <p>C++中的<code>Pimpl</code>、<code>RAII</code>是两种比较常见的编程技巧，之前学过几次，经常只知道名称，具体内容又忘记了，在这里简单做个学习记录。</p>          </div><span id="more"></span><h3 id="一、PImpl-惯用法"><a href="#一、PImpl-惯用法" class="headerlink" title="一、PImpl 惯用法"></a>一、PImpl 惯用法</h3><blockquote><p>PImpl（<strong>P</strong>ointer to <strong>impl</strong>ementation）是一种比较常见的C++编程技巧，采用这种技巧能够减少代码依赖以及编译时间，具体思想是：<u>将类的实现细节（如一些非虚的私有成员）从对象的表示中移除，放到另外的一个类中，并以一个指针（建议是一个独享的指针，如<code>unique_ptr</code>）指向它进行访问。</u></p></blockquote><h4 id="1-1-Pimpl出现的背景？原因？"><a href="#1-1-Pimpl出现的背景？原因？" class="headerlink" title="1.1 Pimpl出现的背景？原因？"></a>1.1 Pimpl出现的背景？原因？</h4><p>在C++中，当头文件中的类定义发生变化，该类所有被使用的地方都<strong>需要重新被编译</strong>，<strong>甚至于更改的地方仅仅是外部无法访问的私有成员数据</strong>，主要原因在于私有成员数据在以下两个方面会影响一个类：</p><ul><li><strong>大小和布局</strong>：代码调用者需要知道类的大小和布局（这会包括私有数据成员），换句话说，它始终要能够看到实现，这种约束会导致调用者和被调用者之间存在更紧密的耦合性。当然这是C++对象模型和哲学的核心，因为需要保证编译器默认情况下可以直接访问对象是使C++实现其著名的高度优化效率的要素。</li><li><strong>函数</strong>：类的私有成员函数也会参与重载决议。</li></ul><p>为了减少这写编译依赖，一般会<strong>采用指针来隐藏一些实现细节</strong>，在C++11中，可以采用如下的<code>Pimpl</code>惯用法写法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;memory&gt;</span></span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>&#123;</span><br>  <span class="hljs-comment">//一些其他需要放在该处的内容，如虚函数什么的</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Impl</span>;</span> <span class="hljs-comment">// 细节类的前向声明</span><br>    <span class="hljs-comment">// 采用unique_ptr 是因为Impl的所有权是A对象所独占的，采用该指针包装器可以更好地表达这一意思</span><br>    std::unique_ptr&lt;Impl&gt; impl_ptr; <span class="hljs-comment">// 指向具体的实现</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>需要提到的是，提到<code>Pimpl</code>惯用法，一般也会提到“<strong>编译防火墙</strong>”。</p><blockquote><p>被称作编译防火墙的原因在于，<u>采用这种技巧能够很好地避免由于更改部分成员而导致编译级联（多处源文件重新编译）</u>。有一个例外，如果实现类是类模板特化，那么就会丧失编译防火墙的优势：接口的用户必须观测到整个模板定义，以实例化正确的特化。</p></blockquote><p>总的来说，它可带来两个很明显的好处：</p><ul><li>编译防火墙，打破编译依赖，省时</li><li>隐藏实现细节，即接口与实现分离</li></ul><h4 id="1-2-C-11中Pimpl惯用法的最佳实践"><a href="#1-2-C-11中Pimpl惯用法的最佳实践" class="headerlink" title="1.2 C++11中Pimpl惯用法的最佳实践"></a>1.2 C++11中Pimpl惯用法的最佳实践</h4><p>前面提到，在C++11及以后的标准，应该尽量避免采用原生的指针（这也是贯彻了<code>RAII</code>的思想）。</p><p>以下面的代码为例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*在头文件中*/</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Widget</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Widget</span>();<br>    ~<span class="hljs-built_in">Widget</span>();<br>    <br>    <span class="hljs-built_in">Widget</span>(Widget &amp;&amp;) <span class="hljs-keyword">noexcept</span> ;<br>    Widget&amp; <span class="hljs-keyword">operator</span>= (Widget &amp;&amp;)   <span class="hljs-keyword">noexcept</span> ;<br><br><br>    <span class="hljs-built_in">Widget</span>(<span class="hljs-keyword">const</span> Widget &amp;) =<span class="hljs-keyword">delete</span>;        <span class="hljs-comment">// 拷贝构造 定义为删除的</span><br>    Widget&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> Widget&amp;) = <span class="hljs-keyword">delete</span>; <span class="hljs-comment">// 复制拷贝 定义为删除的</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Impl</span>;</span><br>    std::unique_ptr&lt;Impl&gt; impl_ptr;<br>    <br>&#125;<br><br><br><span class="hljs-comment">/*在实现的源文件中*/</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Widget</span>:</span>:Impl&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-comment">// 一些细节</span><br>&#125;;<br><br><span class="hljs-comment">// 须在外面进行定义 确保Impl 是完整类型</span><br>Widget::<span class="hljs-built_in">Widget</span>(<span class="hljs-keyword">int</span> n):<span class="hljs-built_in">impl_ptr</span>(std::make_unique&lt;Impl&gt;(n))&#123;<br>&#125;<br><br>Widget::<span class="hljs-built_in">Widget</span>(Widget &amp;&amp;)  <span class="hljs-keyword">noexcept</span> = <span class="hljs-keyword">default</span>;<br>Widget &amp;Widget::<span class="hljs-keyword">operator</span>=(Widget &amp;&amp;)  <span class="hljs-keyword">noexcept</span> = <span class="hljs-keyword">default</span>;<br>Widget::~<span class="hljs-built_in">Widget</span>()=<span class="hljs-keyword">default</span>;<br></code></pre></td></tr></table></figure><p>在这个例子中，其实也就是这套<code>Pimpl</code>模板中：</p><ul><li>采用<code>unique_ptr</code>是<u>为了准确表达<code>Widget</code>对象对<code>Impl</code>对象的所有权是独占的，而不是共享的</u></li><li>由于<code>unique_ptr</code>要求指向的类型在任何实例化删除器的语境中均为完整类型，故特殊成员函数需要用户声明且需在<code>Impl</code>定义后定义</li><li>构造函数也需要在类外定义并且分配<code>Pimpl</code>对象资源</li><li>由于用户自定义了析构函数，所以编译不会生成可移动构造函数和移动赋值运算符（赋值同样），这就需要用户根据需求决定是否提供</li></ul><blockquote><p>额外提一点，<strong>建议将所有<u>私有非虚成员</u>移动到具体的实现类中</strong>，虚函数需要在继承链中可见，故不建议在<code>Pimpl</code>惯用法将其移动到实现类中。</p></blockquote><h4 id="1-3-一个具体的例子"><a href="#1-3-一个具体的例子" class="headerlink" title="1.3 一个具体的例子"></a>1.3 一个具体的例子</h4><p><strong>Widget.h</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><span class="hljs-comment">/********************************************************************************</span><br><span class="hljs-comment">* @author: Huang Pisong</span><br><span class="hljs-comment">* @email: huangpisong@foxmail.com</span><br><span class="hljs-comment">* @date: 2023/8/25 20:48</span><br><span class="hljs-comment">* @version: 1.0</span><br><span class="hljs-comment">* @description: </span><br><span class="hljs-comment">********************************************************************************/</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> TEST_CPP_WORK1_WIDGET_H</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TEST_CPP_WORK1_WIDGET_H</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;memory&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;experimental/propagate_const&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Widget</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> </span>;<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">shown</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Widget</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>;<br><br><br>    <span class="hljs-built_in">Widget</span>(Widget &amp;&amp;) <span class="hljs-keyword">noexcept</span> ;<br>    Widget&amp; <span class="hljs-keyword">operator</span>= (Widget &amp;&amp;)   <span class="hljs-keyword">noexcept</span> ;<br><br>    <span class="hljs-built_in">Widget</span>(<span class="hljs-keyword">const</span> Widget &amp;) =<span class="hljs-keyword">delete</span>;<br>    Widget&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> Widget&amp;) = <span class="hljs-keyword">delete</span>;<br>    <br>    ~<span class="hljs-built_in">Widget</span>();<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Impl</span>;</span>  <span class="hljs-comment">// 前置声明</span><br>    <span class="hljs-comment">/*propagate_const  会传递const从而保证调用的指针是一致的*/</span><br>    std::experimental::propagate_const&lt;std::unique_ptr&lt;Impl&gt;&gt; impl_ptr;  <span class="hljs-comment">// 指向实现类的指针</span><br><br>&#125;;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span> <span class="hljs-comment">//TEST_CPP_WORK1_WIDGET_H</span></span><br><br></code></pre></td></tr></table></figure><p><strong>Widget.cpp</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><span class="hljs-comment">/********************************************************************************</span><br><span class="hljs-comment">* @author: Huang Pisong</span><br><span class="hljs-comment">* @email: huangpisong@foxmail.com</span><br><span class="hljs-comment">* @date: 2023/8/25 20:48</span><br><span class="hljs-comment">* @version: 1.0</span><br><span class="hljs-comment">* @description: </span><br><span class="hljs-comment">********************************************************************************/</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;Widget.h&quot;</span></span><br><br><span class="hljs-comment">// 具体实现</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Widget</span>:</span>:Impl&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">//    Impl():name(&quot;test&quot;),width(0.0),height(0.0)&#123;&#125;;</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Widget&amp; w)</span> <span class="hljs-keyword">const</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (w.<span class="hljs-built_in">shown</span>())<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;drawing a const component&quot;</span> &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Widget&amp; w)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (w.<span class="hljs-built_in">shown</span>())<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;drawing a non const component&quot;</span> &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Impl</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span>:n(n)&#123;</span>&#125;;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> n;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Widget::draw</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;impl_ptr-&gt;<span class="hljs-built_in">draw</span>(*<span class="hljs-keyword">this</span>);&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Widget::draw</span><span class="hljs-params">()</span>  </span>&#123;impl_ptr-&gt;<span class="hljs-built_in">draw</span>(*<span class="hljs-keyword">this</span>);&#125;<br><br><span class="hljs-comment">// 需在外面进行定义 确保Impl 是完整类型</span><br>Widget::<span class="hljs-built_in">Widget</span>(<span class="hljs-keyword">int</span> n):<span class="hljs-built_in">impl_ptr</span>(std::make_unique&lt;Impl&gt;(n))&#123;<br>&#125;<br><br><span class="hljs-comment">//</span><br>Widget::<span class="hljs-built_in">Widget</span>(Widget &amp;&amp;)  <span class="hljs-keyword">noexcept</span> = <span class="hljs-keyword">default</span>;<br>Widget &amp;Widget::<span class="hljs-keyword">operator</span>=(Widget &amp;&amp;)  <span class="hljs-keyword">noexcept</span> = <span class="hljs-keyword">default</span>;<br><br>Widget::~<span class="hljs-built_in">Widget</span>()=<span class="hljs-keyword">default</span>;<br></code></pre></td></tr></table></figure><h3 id="二、-RAII惯用法"><a href="#二、-RAII惯用法" class="headerlink" title="二、 RAII惯用法"></a>二、 RAII惯用法</h3><p>RAII惯用法的使用能够很好地<u>避免由于手动管理资源带来资源泄漏的问题。</u></p><blockquote><p>RAII（Resource Acquisition Is Initialization，资源获取即初始化），是一种<u></u>将必须在使用前请求的资源（如分配的堆内存、执行线程、打开的套接字、打开的文件等）的生命周期与一个对象的生存期相绑定的C++编程技术。</p></blockquote><p>RAII机制保证<u>资源能够用于任何会访问该对象的函数</u>，同时还保证<u>对象在自己生存期结束时会以获取顺序的逆序释放它控制的所有资源。</u></p><p>总的来说，其实就是：</p><ol><li>设计类封装资源（资源绑定对象，生命周期一致性）</li><li>构造函数分配资源 </li><li>析构函数销毁资源</li></ol><p><code>cppreference</code>上的<strong>一个例子</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::mutex m;<br> <br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bad</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>    m.<span class="hljs-built_in">lock</span>();                    <span class="hljs-comment">// 请求互斥体</span><br>    <span class="hljs-built_in">f</span>();                         <span class="hljs-comment">// 如果 f() 抛出异常，那么互斥体永远不会被释放</span><br>    <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">everything_ok</span>()) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 提早返回，互斥体永远不会被释放</span><br>    m.<span class="hljs-built_in">unlock</span>();                  <span class="hljs-comment">// 只有 bad() 抵达此语句，互斥体才会被释放</span><br>&#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">good</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lk</span><span class="hljs-params">(m)</span></span>; <span class="hljs-comment">// RAII类：互斥体的请求即是初始化</span><br>    <span class="hljs-built_in">f</span>();                               <span class="hljs-comment">// 如果 f() 抛出异常，那么就会释放互斥体</span><br>    <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">everything_ok</span>()) <span class="hljs-keyword">return</span>;       <span class="hljs-comment">// 提早返回也会释放互斥体</span><br>&#125;                                      <span class="hljs-comment">// 如果 good() 正常返回，那么就会释放互斥体</span><br></code></pre></td></tr></table></figure><p>像<code>open()/close()</code>、<code>lock()/unlock()</code>等就是非<code>RAII</code>类的例子，显然其没有利用到对象的生命周期。</p><p>而<code>lock_guard</code>是标准库中提供的<code>RAII</code>包装器，用于管理互斥体，在这里使用，可以看到它管理的是<code>std::mutex</code>，当跳出这个函数时，这个资源就会随着<code>lock_guard</code>对象的释放而释放，无需手动去管理。</p><p>再举一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HeapObjectWrapper</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">HeapObjectWrapper</span><span class="hljs-params">(<span class="hljs-keyword">int</span> size)</span></span>&#123;<br>        <span class="hljs-keyword">if</span> (size &lt;= <span class="hljs-number">0</span> || size &gt; <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>)<br>            size = <span class="hljs-number">1024</span>;<br>        m_p = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[size];<br>    &#125;<br><br>    ~<span class="hljs-built_in">HeapObjectWrapper</span>()&#123;<br><br>        <span class="hljs-keyword">delete</span>[] m_p;<br>        m_p = <span class="hljs-literal">nullptr</span>;<br><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;自动释放资源...&quot;</span>  &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">char</span> * m_p;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">HeapObjectWrapper <span class="hljs-title">obj</span><span class="hljs-params">(<span class="hljs-number">1024</span>)</span></span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<span class="hljs-comment">// 到达这里 申请的资源会被释放</span><br></code></pre></td></tr></table></figure><p>在<code>main</code>函数中向堆中申请了1024个堆上的字节，在<code>main</code>函数结束就会调用<code>obj</code>对象的析构函数进行资源的销毁，依然是无需用户手动管理资源，紧紧地跟对象生命周期绑定了。</p><p>RAII<strong>非常适用于在使用前就需要分配的资源</strong>，<strong>不适用于不会在使用前请求的资源</strong>（如CPU时间、核心等）</p><blockquote><p>标准库中也提供了很多包装器来管理用户资源：</p><ul><li><a href="https://zh.cppreference.com/w/cpp/memory/unique_ptr">std::unique_ptr</a> 及 <a href="https://zh.cppreference.com/w/cpp/memory/shared_ptr">std::shared_ptr</a> 用于管理动态分配的内存，或以用户提供的删除器管理任何以普通指针表示的资源；</li><li><a href="https://zh.cppreference.com/w/cpp/thread/lock_guard">std::lock_guard</a>、<a href="https://zh.cppreference.com/w/cpp/thread/unique_lock">std::unique_lock</a>、<a href="https://zh.cppreference.com/w/cpp/thread/shared_lock">std::shared_lock</a> 用于管理互斥体。</li></ul></blockquote><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ul><li><a href="https://herbsutter.com/gotw/_100/">GotW #100: Compilation Firewalls (Difficulty: 6/10) – Sutter’s Mill (herbsutter.com)</a></li><li><a href="https://en.cppreference.com/w/cpp/language/pimpl">PImpl - cppreference.com</a></li><li><a href="https://zhuanlan.zhihu.com/p/458947637">C++编程技巧: Pimpl - 知乎 (zhihu.com)</a></li><li><a href="https://zh.cppreference.com/w/cpp/language/raii">RAII - cppreference.com</a></li><li><a href="https://simonzgx.github.io/2020/07/01/C++-RAII惯用法/">RAII 惯用法 - Blog (simonzgx.github.io)</a></li><li><a href="https://zhuanlan.zhihu.com/p/34660259">c++经验之谈一：RAII原理介绍 - 知乎 (zhihu.com)</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>C/C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C/C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>借助代理解决github被墙</title>
    <link href="/2023/06/13/%E5%80%9F%E5%8A%A9%E4%BB%A3%E7%90%86%E8%A7%A3%E5%86%B3github%E8%A2%AB%E5%A2%99/"/>
    <url>/2023/06/13/%E5%80%9F%E5%8A%A9%E4%BB%A3%E7%90%86%E8%A7%A3%E5%86%B3github%E8%A2%AB%E5%A2%99/</url>
    
    <content type="html"><![CDATA[<div class="note note-primary">            <p>【Win10环境下】自从配置好本地<code>Git</code>后，一般都能够推送到<code>GitHub</code>,但是过段时间后（甚至不用），经常会因为一些奇怪的问题导致无法推送上去，本文尝试通过使用<strong>代理</strong>解决因为<code>Github</code>被墙所产生的问题。</p>          </div><span id="more"></span><h3 id="一、什么是代理？"><a href="#一、什么是代理？" class="headerlink" title="一、什么是代理？"></a>一、什么是代理？</h3><blockquote><p>代理（英语：Proxy）也称网络代理，是一种特殊的网络服务，允许一个终端（一般为客户端）通过这个服务与另一个终端（一般为服务器）进行非直接的连接。源自：<a href="https://zh.wikipedia.org/wiki/代理服务器">代理服务器 - 维基百科，自由的百科全书 (wikipedia.org)</a></p></blockquote><p>通俗的理解就是，本来客户端是直连服务端的，现在往它们的通信线路中间插入了一个服务，这个服务将代替客户端访问服务端，同时将服务端的响应返回到客户端。</p><p><img src="https://img.kilig.ink/img_blog/%E4%BB%A3%E7%90%86.svg" alt=""></p><p>这样带来的好处就是：</p><ol><li>能够突破某些限制，进而能够访问被过滤的网站</li><li>提高访问的速度</li><li>隐藏真实的IP</li><li>突破网站的区域限制。</li></ol><p>为了能够使用代理，你必须手头上能够有一台<strong>服务器</strong>（该服务器能够直接访问<code>GitHub</code>不受限制）或者是<code>VPN</code>。</p><p>因为<code>VPN</code>工具实际上已经是通过代理的方式来协助我们上网了，所以可以在<code>Git</code>发起<code>SSH</code>请求的时候通过它建立的线路来访问，这也是本文采用的方法。</p><h3 id="二、问题描述"><a href="#二、问题描述" class="headerlink" title="二、问题描述"></a>二、问题描述</h3><blockquote><p>在这里主要是重新提一下我遇到的问题。</p></blockquote><p>当我将本地提交的代码想要推送到远程仓库时，如<code>GitHub</code>，经常会报如下内容的错误：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">kex_exchange_identification:Connectlon closed by remote host<br>Connection closed by 20.205.243.166 port 22<br>fatal: Could not read from remote repository.<br>please make sure you have the correct access rights<br></code></pre></td></tr></table></figure><p>当然，遇到这个错误的时候，首先要确定你的远程仓库路径是正确的并且具备一定的访问权限，不然就不好确定是哪方面的问题了。我当时遇到这个问题的时候，也尝试了许多比较常见的方法（以关键词<code>kex_exchange_identification:Connectlon closed by remote host</code>进行搜索），但是没有什么用。<strong>后面甚至突然出现能够推送上去的情况，这让我联想到可能是被墙的原因导致推送并不稳定。</strong></p><p>但是我也开了<strong>全局代理</strong>，我以为这样它就不会绕开代理了，但实际上，我在日志上并没查到有访问<code>GitHub</code>的日志信息，故我猜测还是需要单独设置<code>Git</code>走代理模式。</p><h3 id="三、解决方案"><a href="#三、解决方案" class="headerlink" title="三、解决方案"></a>三、解决方案</h3><blockquote><p>如果没有配置Git采用SSH方式来访问<code>GitHub</code>的话，请配置后再按如下的方式进行设置，具体配置方式请自行百度。</p></blockquote><p>前往<code>C:\Users\your_user_name\.ssh</code>（像我的用户名为<code>pSomng</code>，所以路径是<code>C:\Users\pSomng\.ssh</code>）目录下,找到<code>config</code>文件，如果没有就创建一个，然后配置如下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs txt"><br>#这里的connetct路径是你的Git安装路径，并找到对应的connect路径 然后修改对应的端口 这里的7890 是我的VPN工具的端口号<br># 这个方式将会配置全局SSH走代理的方式<br># ProxyCommand &quot;E:\SOFTWARE\Git\mingw64\bin\connect&quot; -S 127.0.0.1:7890 -a none %h %p<br><br>Host github.com<br>  User git<br>  Port 22<br>  Hostname github.com<br>  # 修改路径为你的路径 采用私钥免密SSH<br>  IdentityFile &quot;C:\Users\your_user_name\.ssh\id_rsa&quot;<br>  # 针对访问GitHub设置代理（推荐）<br>  ProxyCommand &quot;E:\SOFTWARE\Git\mingw64\bin\connect&quot; -S 127.0.0.1:7890 -a none %h %p<br>  TCPKeepAlive yes<br><br>Host ssh.github.com<br>  User git<br>  Port 443<br>  Hostname ssh.github.com<br>  # 修改路径为你的路径 采用私钥免密SSH<br>  IdentityFile &quot;C:\Users\your_user_name\.ssh\id_rsa&quot;<br>  ProxyCommand &quot;E:\SOFTWARE\Git\mingw64\bin\connect&quot; -S 127.0.0.1:7890 -a none %h %p<br>  TCPKeepAlive yes<br><br></code></pre></td></tr></table></figure><p><strong>记住要根据自己实际的参数值来实际配置上面这些参数。</strong></p><p>里面提到的<code>7890</code>是我的<code>VPN</code>工具所采用的端口号：</p><p><img src="https://img.kilig.ink/img_blog/%E7%AB%AF%E5%8F%A3%E5%8F%B7.png" alt=""></p><p>然后执行下面的命令进行测试：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh -T git@github.com<br></code></pre></td></tr></table></figure><p>如果出现下面的内容，则说明已经配置成功了</p><blockquote><p>Hi xxxx! You’ve successfully authenticated, but GitHub does not provide shell access.</p></blockquote><p>好了，现在就可以愉快地获取<code>GitHub</code>的内容、上传数据到<code>GitHub</code>了。</p><p><em>如果本文存在哪里说的不对的地方，请您指出以便于我及时更改，谢谢！</em></p><h3 id="四、参考文章"><a href="#四、参考文章" class="headerlink" title="四、参考文章"></a>四、参考文章</h3><ul><li><p><a href="https://tjfish.top/posts/git设置代理解决被墙/">Git设置代理解决被墙 | TjFish</a></p></li><li><p><a href="https://gist.github.com/chenshengzhi/07e5177b1d97587d5ca0acc0487ad677">git ssh 代理设置 (github.com)</a></p></li><li><p><a href="https://zh.wikipedia.org/wiki/代理服务器">代理服务器 - 维基百科，自由的百科全书 (wikipedia.org)</a></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
      <tag>Github</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>吴恩达机器学习笔记3: 逻辑回归</title>
    <link href="/2022/01/15/%E5%90%B4%E6%81%A9%E8%BE%BE%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03-%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/"/>
    <url>/2022/01/15/%E5%90%B4%E6%81%A9%E8%BE%BE%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03-%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/</url>
    
    <content type="html"><![CDATA[<h3 id="1-分类问题"><a href="#1-分类问题" class="headerlink" title="1.分类问题"></a>1.分类问题</h3><p>在谈及机器学习的监督学习算法时，基本都能脱口而出其主要作用于回归与分类，前面的文章已经谈过了回归问题的相关算法，所以本文来学习一下分类问题中流行的学习算法: <strong>逻辑回归(Logistic Regression）</strong>。在分类问题中，模型所需要预测的$y$值（变量）是离散的，即我们尝试预测的是结果是否是属于某一个类别(真/假?)。</p><p><strong>分类问题的例子有:</strong></p><ul><li>邮件: 垃圾邮件/正常邮件?</li><li>线上交易:  是否是诈骗?</li><li>肿瘤: 恶性?良性？</li></ul><p>以二分类问题为例，假设把因变量(<strong>dependent variable</strong>)可能属于的两个类分别称为负向类(<strong>negative class</strong>)和正向类(<strong>positive class</strong>)，用数字表示这两个类（0表示负向类，例: 良性肿瘤；1表示正向类，例:恶性肿瘤。），则因变量$y \in{0,1}$。</p><p>假设有如图1-1的样本分布:</p><p><img src="P3.png" alt="图1-1"></p><p>现在希望的是能够采用某种算法能够在已有数据集的基础上构造模型去预测给定肿瘤大小的类别是什么?恶性还是良性。</p><p>基于学过的线性回归算法，此处采用线性回归算法去拟合，如图1-2所示:</p><p><img src="image-20220114163053100.png" alt="图1-2"></p><p>假设把该分类器的输出$h_θ(x)$的阈值定为0.5:</p><ul><li>如果$h_θ(x)≥0.5$，预测$y=1$，即为恶性肿瘤。</li><li>如果$h_θ(x)＜0.5$，预测$y=0$，即为良性肿瘤。</li></ul><p>显然，可以从图中看出，这个算法在该例子上表现还是不错的，但是如果考虑增加一个额外的样本，如图1-3所示:</p><p><img src="P2.png" alt="图1-3"></p><p>还是把该分类器的输出的阈值定为0.5,可以从图中看出，相比上一个来说，该分类器的表现并不是很好，可见，线性回归算法受该样本的影响还是蛮大的，还有另一个问题就是在线性回归中的$h_θ(x)$的值可能远大于1或是远小于0，尽管我们知道选取标签还是0或1，但是还会觉得有点奇怪，因为它预测的值超过了$[0,1]$这个范围。</p><p>为了解决上述问题，在分类问题中常用的是<strong>逻辑回归算法</strong>，它的性质是:能够保证输出值在0到1之间，即$0≤h_θ(x)≤1$。</p><blockquote><p><strong>逻辑回归算法是分类算法，它适用于标签$y$取值离散的情况。</strong>另，对于多分类，$y$的取值可能有多种，而不仅仅是0和1。</p></blockquote><h3 id="2-假设表示"><a href="#2-假设表示" class="headerlink" title="2. 假设表示"></a>2. 假设表示</h3><p>上文已经提到过线性回归算法中的假设函数<script type="math/tex">h_θ(x)</script>所预测的值可能会超过<script type="math/tex">[0,1]</script>这个范围，会对预测结果的准确性带来一些影响。所以为了保证<script type="math/tex">0≤h_θ(x)≤1</script>，引入了逻辑回归模型假设: <script type="math/tex">h_θ(x)=g(θ^TX)</script>,其中<script type="math/tex">θ</script>是参数向量，$X$为特征向量，g代表逻辑函数(或Sigmoid 函数),公式为:</p><script type="math/tex; mode=display">g(z)=\frac{1}{1+e^{-z}} \tag1</script><p>该函数的图像为:</p><p><img src="image-20220114193943980.png" alt="图2-1"></p><p>可见，经过sigmoid函数的映射，假设函数的输出已经能够保证是在$[0,1]$的范围内了。不过，这个$h_θ(x)$的输出到底表达的是怎样的一个意思？</p><p><strong>在吴恩达老师的视频里，他把$h_\theta(x)$当作是在给定输入特征$x$下评估$y=1$的可能性。</strong></p><p>以一个例子来说明，假设</p><script type="math/tex; mode=display">x=\left[\begin{matrix}  x_0  \\   x_1  \\   \end{matrix}\right]=\left[\begin{matrix}  1  \\   tumorSize  \\   \end{matrix}\right]\tag{2}</script><p>假设函数输出为<script type="math/tex">h_\theta(x)=0.7</script>，则是相当于告诉病人有70%的可能该肿瘤是恶性的。用概率论的方式表示就是$h_\theta(x)=P(y=1|x;\theta)$，其意思就是:在给定的特征x下，通过给定的参数θ的情况，$y=1$的可能性是多少?对应的，我们也能够求得$y=0$的可能性。</p><p>因为：$P(y=0|x;\theta)+P(y=1|x;\theta)=1$</p><p>移项可得：$P(y=0|x;\theta)=1-P(y=1|x;\theta)$</p><h3 id="3-决策边界"><a href="#3-决策边界" class="headerlink" title="3. 决策边界"></a>3. 决策边界</h3><p>先简单描述一下，什么时候预测y为1或是0。假设<script type="math/tex">h_\theta(x)≥0.5</script>时预测$y=1$，<script type="math/tex">h_\theta(x)<0.5</script>时预测$y=0$，又因为<script type="math/tex">h_θ(x)=g(θ^TX)</script>以及Sigmoid函数的图像，可以简化理解为: <script type="math/tex">\theta^TX≥0</script>即<script type="math/tex">h_\theta(x)≥0.5</script>,此时预测$y=1$，与此同理，$\theta^TX＜0$即$h_\theta(x)＜0.5$，此时预测$y=0$。(0.5作为输出的阈值)</p><p>那么什么是“决策边界”呢？大白话就是: <strong>用以区分不同类别的分界线，可以是直线，也可以是曲线等，它不是数据集的属性，是假设函数的属性并由其参数所决定。</strong></p><p>下面以一些例子进行形象的一个表示:</p><p>假设有这样的一个模型:</p><script type="math/tex; mode=display">h_\theta(x)=g(\theta_0+\theta_1x_1+\theta_2x_2)\tag{3}</script><p>以及一个数据集，其分布如图3-1所示:</p><p><img src="image-20220114210641455.png" alt="图3-1"></p><p>现在假设我们经过梯度下降算法，已经求得三个参数的值:-3，1，1。则当$-3+x_1+x_2≥0$时，即当$x_1+x_2≥3$时，将预测$y=1$。此时在图3-1绘制一下直线$x_1+x_2=-3$，如图3-2所示:</p><p><img src="image-20220114211128778.png" alt="图3-2"></p><p>可以从图中看出该条直线已经将$y=1$和$y=0$的两块区域区分开来了，此时的分界线即为<strong>决策边界</strong>，用于根据输入的特征进行决策输出值该归于哪一类。</p><p>再看一个例子，假设数据分布如图3-3所示:</p><p><img src="image-20220114211512936.png" alt="图3-3"></p><p>此时在用直线是无法将两个不同的类别区分开来的，这时的模型定为:</p><script type="math/tex; mode=display">h_\theta(x)=g(\theta_0+\theta_1x_1+\theta_2x_2+\theta_3x_1^2+\theta_4x_2^2)\tag{4}</script><p>类似的，已知其参数为:-1，0，0，1，1，则$-1+x_1^2+x_2^2≥0$时，预测$y=1$，并在图3-3中绘制曲线$x_1^2+x_2^2=-1$，如图3-4所示:</p><p><img src="image-20220114212041440.png" alt="图3-4"></p><p>可以从图中看出，以该曲线作为决策边界已经成功将$y=0$和$y=1$的区域区分开来了。</p><p>在现实中，我们可能会遇到更为复杂的数据分布，但是我们还是可以选择使用更为复杂的模型去适应复杂的数据分布。</p><h3 id="4-代价函数"><a href="#4-代价函数" class="headerlink" title="4.代价函数"></a>4.代价函数</h3><p>前面的部分已经提到过了假设函数以及决策边界，现在问题是如何求得参数θ?具体如图4-1所示:</p><p><img src="image-20220114212719387.png" alt="图4-1"></p><p>在线性回归的那部分中的代价函数表达为:</p><script type="math/tex; mode=display">J(\theta)=\frac{1}{2m}\sum_{i=1}^{m}(h_\theta(x^{(i)})-y^{(i)})^2\tag{5}</script><p>它代表的是误差的平方和，从理论上来说，应该也是可以对逻辑回归模型沿用该定义。但是，当我们将上文提到的假设$h=g(\theta^TX)$带入该代价函数中时，得到的代价函数将是一个非凸函数(<strong>non-convexfunction</strong>)，如图4-2所示:</p><p><img src="image-20220114213601043.png" alt="图4-2"></p><p>从凸函数(右图)与非凸函数(左图)的对比来说，显而易见，<strong>非凸函数存在多个局部最小值</strong>，它不像凸函数一样全局仅有一个最小值，这对于使用梯度下降算法获取全局最小值是非常不利的。</p><p>所以，要对该代价函数进行定义:</p><script type="math/tex; mode=display">J(\theta)=\frac{1}{m}\sum_{i=1}^{m}Cost(h_\theta(x^{(i)}),y)\tag{6}</script><p>其中，$Cost(h_\theta(x,y)$ 定义为:</p><script type="math/tex; mode=display">Cost(h_\theta(x),y)=\left\{ \begin{matrix}-\log(h_\theta(x)) \space if \space y=1 \\-\log(1-h_\theta(x)) \space if \space y=0 \\\end{matrix}\right.\tag{7}</script><p>其中，<script type="math/tex">h_\theta</script>与$Cost(h_\theta(x,y)$ 之间的关系如图4-3所示:</p><p><img src="image-20220114215128360.png" alt="4-3"></p><p>可以从图中看出，如果实际是<script type="math/tex">y=1</script>，如果<script type="math/tex">h_\theta(x)</script>输出的值也为1，那么误差则为0，如果<script type="math/tex">h_\theta(x)</script>不为1，则误差随着<script type="math/tex">h_\theta(x)</script>的 变小而变大(可以从图中看出，当<script type="math/tex">h_\theta(x)</script>趋于0时，误差值是趋于无穷的，这也是蛮符合常理的，因为此时<script type="math/tex">y=1</script>)。类似的，如果实际上的<script type="math/tex">y=0</script>，如果<script type="math/tex">h_\theta(x)</script>输出的值为0，则对应的误差也为0，如果<script type="math/tex">h_\theta(x)</script>不为0，则误差随着<script type="math/tex">h_\theta(x)</script>的变大而变大。</p><p>通过重新定义，可以看到该代价函数已经是凸函数了，这时再利用梯度下降算法就可以很容易获得使得代价函数全局最小时的参数了。</p><h3 id="5-代价函数简化与梯度下降"><a href="#5-代价函数简化与梯度下降" class="headerlink" title="5.代价函数简化与梯度下降"></a>5.代价函数简化与梯度下降</h3><p>为了方便计算机进行运算，需要对式(7)进行简化:</p><script type="math/tex; mode=display">J(\theta)=\frac{1}{m}\sum_{i=1}^{m}Cost(h_\theta(x^{(i)}),y^{(i)})\\=-\frac{1}{m}[\sum_{i=1}^{m}y^{(i)}\log h_\theta(x^{(i)})+(1-y^{(i)})\log(1-h_\theta(x^{(i)}))]\tag8</script><p>经过简化后，$J(\theta)$已经能够同时计算标签为0和1时的误差值了。上文已经提过该函数为凸函数，下一步就是根据$J(\theta)$采用<strong>梯度下降算法</strong>获得对应的参数$\theta$。</p><p>梯度下降算法在文章：<a href="https://blog.dreamforme.top/2022/01/12/吴恩达机器学习笔记2-线性回归/">吴恩达机器学习笔记2: 线性回归</a>，已经做了较为详细的描述。为了获取使$J(\theta)$最小的参数值，需要进行如图5-1的操作（未进行求偏导）:</p><p><img src="image-20220115144030024.png" alt="图5-1"></p><p>通过不断修正参数$\theta$的值，使其逐步移动到全局最小点。其中难点在于: <strong>计算偏导数</strong>。</p><p>求导后的算法模板如图5-2所示（<strong>图中少了$\frac{1}{m}$</strong>）:</p><p><img src="image-20220115144428588.png" alt="图5-2"></p><p>推导过程（<strong>此处的$\log=\ln$，下述求导均按照$ln$的求导法则就行求导，为了表达方便，去掉了上标</strong>）：</p><p>令<script type="math/tex">I=y\log(h_\theta(x))+(1-y)\log(1-h_\theta(x))</script>，求<script type="math/tex">\frac{\partial J(\theta)}{\partial \theta}</script>实际上是求$\frac{\partial I}{\partial \theta}$，其为:</p><script type="math/tex; mode=display">\frac{\partial I}{\partial \theta}=\frac{y}{h_\theta(x)}\cdot\frac{\partial h_\theta(x)}{\partial \theta} + \frac{1-y}{1-h_\theta(x)}\cdot(-1)\cdot\frac{\partial h_\theta(x)}{\partial \theta}\\=[\frac{y-h_\theta(x)}{h_\theta(x)\cdot(1-h_\theta(x))}]\cdot\frac{\partial h_\theta(x)}{\partial \theta}\tag{9}</script><p>已知$h_\theta(x)=\frac{1}{1+e^{-\theta^Tx}}$，对其求导为:</p><script type="math/tex; mode=display">\frac{\partial h_\theta(x)}{\partial \theta}=\frac{1}{(1+e^{-{\theta^Tx}})^2}\cdot e^{-\theta^Tx}\cdot x\\=\frac{1}{1+e^{-\theta^Tx}}\cdot\frac{e^{-\theta^Tx}}{1+e^{-\theta^Tx}}\cdot x\\=h_\theta(x)\cdot(1-h_\theta(x))\cdot x \tag{10}</script><p>联合式(9)与式(10)，可得:</p><script type="math/tex; mode=display">\frac{\partial I}{\partial \theta}=(y-h_\theta(x))\cdot x\tag{11}</script><p>将其带入到$\frac{\partial J(\theta)}{\partial \theta}$中，可得（不再省略上标）:</p><script type="math/tex; mode=display">\frac{\partial J(\theta)}{\partial \theta}=\frac{1}{m}\sum_{i=1}^{m}(h_\theta(x^{(i)})-y^{(i)})\cdot x^{(i)}\tag{12}</script><blockquote><p> 注: 尽管该条等式与线性回归中求偏导的算法公式形式一致，但此处的$h_\theta(x)$是与线性回归中的假设函数是不一样的。<strong>在梯度下降的时候，如果不同特征之间的数据差异过大，适当的特征缩放是很有必要的</strong></p></blockquote><p>求得参数$\theta$的方式有很多，除了梯度下降算法外，还有: 共轭梯度(<strong>Gradient descent</strong>)、变尺度法(<strong>BFGS</strong>)和限制变尺度法<strong>(L-BFGS</strong>)等，它的好处在于: 不需要手动地选取学习率$\alpha$、速度快于梯度下降，但也有缺点: 算法更为复杂。如果有多余的时间，可以尝试去了解这些算法。</p><h3 id="6-多分类问题-一对多"><a href="#6-多分类问题-一对多" class="headerlink" title="6.多分类问题: 一对多"></a>6.多分类问题: 一对多</h3><p>多分类问题不像二分类问题，它需要预测的离散不止有2个，比如:</p><ul><li>邮件归类: 来自工作的邮件（用$y=0$表示）、来自朋友的邮件（用$y=$1表示）、来自家庭的邮件（用$y=2$表示）、来自兴趣爱好的邮件（用$y=3$表示）。</li><li>医疗诊断: 没有生病（用$y=0$表示）、感冒（用$y=1$表示）、流感（用$y=2$表示）等。</li><li>天气：晴天（用$y=0$表示）、多云（用$y=$1表示）、雨天（用$y=2$表示）、下雪天（用$y=3$表示）等</li></ul><p>二分类和多分类的数据分布可能是如图6-1所示的样子（图中使用了不同的符号表达不同的类别）:</p><p><img src="image-20220115162304862.png" alt="图6-1"></p><p>利用“一对多”的思想，可以利用逻辑回归算法构建模型进行预测。不过这里应该有个疑问:<strong>逻辑回归算法中的是直线，只能够区分正类和负类，多分类是如何解决的?</strong> 其解决方案为：创建新的“伪”训练集，将某一个类别定义为正类，其他类别为负类，这样就可以定义了3条曲线（此时假设三角形类别定义为$y=1$表示，方框类别定义为$y=2$表示，叉叉类别定义为$y=3$表示）。如图6-2所示，分别是3条直线所作的决策边界:</p><p><img src="image-20220115163859282.png" alt="图6-2"></p><p>并使用$h_\theta^{(i)}(x)$表示每一个类别的预测结果（预测$y=i$的可能性），那么对应新输入的特征$x$，可以根据不同类别的预测结果进行判别，取最大可能性的类别作为预测的结果。</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
      <tag>人工智能</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>吴恩达机器学习笔记2: 线性回归</title>
    <link href="/2022/01/12/%E5%90%B4%E6%81%A9%E8%BE%BE%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02-%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/"/>
    <url>/2022/01/12/%E5%90%B4%E6%81%A9%E8%BE%BE%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02-%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/</url>
    
    <content type="html"><![CDATA[<blockquote><p>线性回归(Linear regression)试图学得一个线性模型以尽可能准确地预测实值（连续值）输出标记。<span id="more"></span></p></blockquote><h3 id="1-单变量线性回归-Linear-Regression-with-One-Variable"><a href="#1-单变量线性回归-Linear-Regression-with-One-Variable" class="headerlink" title="1 单变量线性回归(Linear Regression with One Variable)"></a>1 单变量线性回归(Linear Regression with One Variable)</h3><blockquote><p>单变量线性回归指的是在构造的模型中只有一个自变量/特征。</p></blockquote><h4 id="1-1-模型表示-Model-Representation"><a href="#1-1-模型表示-Model-Representation" class="headerlink" title="1.1 模型表示(Model Representation)"></a>1.1 模型表示(Model Representation)</h4><p>下面以一个预测住房价格的例子开始，如图1所示，横轴表示房子的面积大小，纵轴表示房子的售卖价格。如果给出一个房子的面积大小，比如1250平方尺大小，要能估计出该房子能够卖多少钱？那么，首要做的就是构建一个模型，可能是直线，也有可能是其他。</p><p><img src="房价图.png" alt="图1-房价图"></p><p>如图2所示是房屋交易问题的例子所提供的训练集(Training Set)。</p><p><img src="image-20220107123448554.png" alt="图2-训练集"></p><p>在本文中描述该回归问题的标记如下:</p><ul><li>$m$代表训练集中实例的数量</li><li>$x$ 代表特征/输入变量</li><li>$y$ 代表目标变量/输出变量</li><li>$(x,y)$ 代表训练集中的实例</li><li>$(x^{(i)},y^{(i)})$ 代表第$i$个观察实例</li><li>$h$ 代表学习算法的解决方案或函数（表示映射关系），也被称为假设(<strong>hypothesis</strong>)</li></ul><p>如图3所示，表示的是一个监督学习算法的工作方式:</p><p><img src="image-20220107124818827.png" alt="图3-监督学习算法的工作方式"></p><p>从图中可知，首先就是提供一个训练集（此处该训练集是房屋价格）给学习算法，然后该学习算法能够输出一个函数，采用$h$表示，它是一个自变量到因变量的函数映射。然后提供一个输入，这里是房子的大小，它能够估算出价格。</p><p>那么这个假设函数$h$如何表达？视频中提供了一种可能的表达方式（只有一个因变量）: $h_{θ}(x)=θ_0+θ_1x$ </p><h4 id="1-2-代价函数-Cost-Function"><a href="#1-2-代价函数-Cost-Function" class="headerlink" title="1.2 代价函数(Cost Function)"></a>1.2 代价函数(Cost Function)</h4><p>在1.1小节中，我们提供了一个假设函数: $h_{θ}(x)=θ_0+θ_1x$，现在需要考虑的是如何为该假设函数（模型）选定一个合适的参数使得与数据的拟合效果更好，如图4:</p><p><img src="image-20220107130156145.png" alt="图4"></p><p>针对不同的$θ_0$和$θ_1$，该假设函数的图形表达也不一样，如图5所示:</p><p><img src="image-20220107130457391.png" alt="图5"></p><p>这里还需要考虑一个术语“建模误差”，在图5中我们选择不同的参数得到了不同的函数表示，为了能够更好表示得到的直线相对于训练集的准确程度，采用“建模误差”表示模型所预测的值与训练集中实际值的差距（图中蓝线所指），如图6所示:</p><p><img src="image-20220107131329629.png" alt="图6"></p><p>我们的目标便是选择出可以使得建模误差的平方和能够最小的模型参数，这里提供一个代价函数:</p><script type="math/tex; mode=display">J(θ_0,θ_1)=\frac{1}{2m}\sum_{i=1}^{m}{(h_{θ}(x^{(i)})-y^{(i)})^2}</script><p>该代价函数也被称作平方误差函数（或是 平方误差代价函数），在这里要求出误差的平方和就是因为误差平方代价函数对于大多数问题（特别是本例所属的回归问题）都是一个合理的选择。</p><p>以该代价函数绘制一个等高线图，三个坐标分别为$θ_0$、$θ_1$和$J(θ_0,θ_1)$，如图7所示:</p><p><img src="image-20220107133145776.png" alt="图7"></p><p>可以从图中看出，在三维空间中是可以找出一个使得$J(θ_0,θ_1)$最小的点。</p><p>为了更好的理解代价函数具体是怎么做，下面对假设函数进行简化，如图8所示:</p><p><img src="image-20220107135418521.png" alt="图8"></p><p>简化后的假设函数仅有一个参数,相对应的，代价函数也变成了只有一个自变量。假设有这样的一组数据: （1，1）、（2，2）、（3，3），针对不同的参数，我们可以作出在坐标轴上绘制出简化后的假设函数与代价函数的图形，如图9:</p><p><img src="image-20220107140149241.png" alt="图9"></p><p>可以见到，当代价函数<script type="math/tex">J(θ_1)</script>取 <script type="math/tex">θ_1=1</script> 时得到最小值，此时的假设函数 <script type="math/tex">h_{θ}(x)</script> 对数据的拟合效果最好。</p><p>通过对假设函数的简化，我们已经基本了解代价函数，继续回到最初的假设函数（不再做简化），如图9所示:</p><p><img src="image-20220107141037863.png" alt="图10"></p><p>现在针对以上的假设函数和代价函数绘制对应的图形表示，如图11所示:</p><p><img src="image-20220107141524996.png" alt="图11"></p><p>代价函数采用等高线图表示（横轴表示$θ_0$，纵轴表示$θ_1$），在一个环中的$J(θ_0,θ_1)$值是相等的,越接近中心圆环，假设函数对于训练集的拟合效果越好，如图12所示:</p><p><img src="image-20220107142008312.png" alt="图12"></p><h4 id="1-3-梯度下降-Gradient-descent"><a href="#1-3-梯度下降-Gradient-descent" class="headerlink" title="1.3 梯度下降(Gradient descent)"></a>1.3 梯度下降(Gradient descent)</h4><blockquote><p>1.2小节给出了代价函数的定义，并通过图解表达假设函数和代价函数，但是还需思考如何获得代价函数的最小值。梯度下降是一个用来求解函数最小值的算法，它的思想在于: 开始时随机选取一个参数的组合$(θ_0,θ_1,θ_2,…,θ_n)$，计算代价函数，然后寻找下一个能让代价函数值下降最多的参数组合，不断迭代，直到能够找到一个局部最小值(local minimum)，因为还未尝试完所有的参数组合，所示无法确定该局部最小值是否为全局最小值，选择不同的初始参数组合，可能会得到不同的局部最小值，如图13所示是简要的算法描述。</p></blockquote><p><img src="image-20220107143555754.png" alt="图13"></p><p>可以想象一下，假设我们站在如图14所示的山顶上，采用梯度下降算法就是看一下周围哪个方向下山是最快的，然后就沿着该方向迈着步伐下去，到了下一个点之后继续看周围，选择一个下山最快的方向继续迈着步伐向下走，不断重复，直到接近局部最低点的位置。</p><p><img src="image-20220107145111401.png" alt="图14"></p><p>批量梯度下降(batch gradient descent)算法的公式如图15所示:</p><p><img src="image-20220107145928038.png" alt="图15"></p><p>其中$α$表示学习率(learning rate)，它决定了我们沿着能让代价函数下降程度最大的方向向下迈出的步子有多大。在批量梯度下降中，每一次都<strong>同时</strong>让所有的参数减去学习速率乘以代价函数的导数，如图16所示。</p><p><img src="image-20220107150413246.png" alt="图16"></p><p>但是，在更新这两个值的时候，可能由于我们的疏忽大意，写成了如图17所示的样子，这就不是所有参数同步更新的，对于$θ_1$来说，它更新的值总是基于更新后的$θ_0$获得，这有可能会对最终结果产生影响。</p><p><img src="image-20220107150728115.png" alt="图17"></p><p>为了便于理解，对于原式中的$\frac{\partial }{\partial θ_i}J(θ_0,θ_1)$进行简化为: $\frac{\mathrm{d} }{\mathrm{d} θ_i}J(θ)$，在图形表示上，就可以把它当作是对该代价函数求导，导数的几何意义也是斜率，以该斜率在该点做一条切线，易知，切线方向就是该函数变化最快的方向，所以，沿着该方向，我们可以更快到达最低点，这就是梯度下降算法的更新规则。</p><p><img src="image-20220107152218883.png" alt="图18"></p><p>其中有一个参数$α$也是不可以忽视的，它决定了步子迈开的大小，考虑下面两种情况:</p><ul><li>$α$太小，即学习速率太小，那么就会导致步子迈的很小，不难想像，这需要很多步才能达到最低点。</li><li>$α$太大，即学习速率过大，那么梯度下降法可能会越过最低点，甚至于无法收敛。</li></ul><p>如图19所示:</p><p><img src="image-20220107153725869.png" alt="图19"></p><p>再看另外的一个例子，可以从图中看的，当取定一个$θ_1$的值(如图20中红色的点)，它的导数是相当陡峭的，在不断移动的过程中，当前的点的导数会逐渐趋于0，即<strong>梯度下降法中更新的幅度会越来越小，直到收敛到局部的最小值</strong>（其中并未更新$α$，所以无需更新该值也能使得代价函数收敛到最小值）。</p><p><img src="image-20220107154521976.png" alt="图20"></p><p>该梯度下降算法可以用来最小化任何代价函数，不只是线性回归中的代价函数。</p><h4 id="1-4-梯度下降的线性回归-Gradient-Descent-For-Linear-Regression"><a href="#1-4-梯度下降的线性回归-Gradient-Descent-For-Linear-Regression" class="headerlink" title="1.4 梯度下降的线性回归(Gradient Descent For Linear Regression)"></a>1.4 梯度下降的线性回归(Gradient Descent For Linear Regression)</h4><p>通过将梯度下降算法和代价函数相结合，并将其应用于拟合直线的线性回归算法里，图21是梯度下降算法与线性回归算法的比较。</p><p><img src="image-20220107155006176.png" alt="图21"></p><p>对之前提到的线性回归算法运用梯度下降算法，关键在于求出代价函数相对于各参数的导数，即偏导,如图22所示:</p><p><img src="image-20220107160012178.png" alt="图22"></p><p>那么算法就可以进一步改写为图23的样子:</p><p><img src="image-20220107160144823.png" alt="图23"></p><p>该算法之所以被称为“批量梯度下降”算法，是因为在梯度下降的每一步中，都用到所有的训练样本，在梯度下降中计算微分求导项时，需要进行求和运算。在每一个单独的梯度下降中，最终都要对所有$m$个训练样本求和。事实上，还有其他类型的梯度下降算法，不考虑整个训练集，每次只关注训练集中的一些小的子集。</p><h3 id="2-多变量线性回归"><a href="#2-多变量线性回归" class="headerlink" title="2 多变量线性回归"></a>2 多变量线性回归</h3><p><strong>所谓多变量线性回归指的是其自变量不再像是单变量线性回归一样仅有一个，而是多个。</strong>如之前考虑的预测房价的例子来说，房价的决定因素不再是仅仅由房子的面积大小而唯一确定，还可能会受到卧室数量、楼层数量以及房子的使用年限等多重因素所影响，如图2-1。</p><p><img src="合成图.png" alt="图2-1"></p><p>为了确保提出的模型更加准确地预测结果，提出的假设函数应该考虑多个特征，所以假设函数应该是这样的:</p><script type="math/tex; mode=display">h_θ(x)=θ_0+{θ_1}{x_1}+{θ_2}{x_2}+...+{θ_n}{x_n}</script><p>显而易见，单变量线性回归中的假设函数其实该假设函数的特例。如果我们保证$x_0==1$（为了方便记忆），上述假设函数可以改写为:</p><script type="math/tex; mode=display">h_θ(x)={θ_1}{x_0}+{θ_1}{x_1}+{θ_2}{x_2}+...+{θ_n}{x_n}=θ^TX</script><p>其中$θ^T$是表示<code>θ</code>向量的转置，<code>X</code>也是向量。</p><h4 id="2-1-多变量的梯度下降-Gradient-descent-for-multiple-variables"><a href="#2-1-多变量的梯度下降-Gradient-descent-for-multiple-variables" class="headerlink" title="2.1 多变量的梯度下降(Gradient descent for multiple variables)"></a>2.1 多变量的梯度下降(Gradient descent for multiple variables)</h4><p>应用在多变量的梯度下降算法与应用于单变量的梯度下降算法没什么区别，前者求<code>θ</code>的数量不再是指明的1个或者2个。为了更好的表达，这里的参数使用<code>θ</code>向量表示，其中$θ_1$、$θ_2$…$θ_n$为其元素。如图2-2所示，其中包含了针对多变量线性回归的假设函数(Hypothesis)、参数(Parameters)、代价函数(Cost function)以及梯度下降算法(Gradient descent)。</p><p><img src="梯度下降-1.png" alt="图2-2 梯度下降-1"></p><p>代价函数可以改写为（其中<code>θ</code>为向量）:</p><script type="math/tex; mode=display">J(θ)=\frac{1}{2m}\sum_{i=1}^{m}{(h_{θ}(x^{(i)})-y^{(i)})^2}</script><p>如图2-3所示，是<code>n==1</code>与<code>n≥1</code>时梯度下降算法比较，后者更一般化。此处的$θ_0$的更新公式与其他参数无异，当我们考虑把$x_0$置为1，显而易见，其公式就可以归纳于通式中了。</p><p><img src="梯度下降-2.png" alt="图2-3 梯度下降-2"></p><h5 id="1-特征缩放"><a href="#1-特征缩放" class="headerlink" title="1 特征缩放"></a>1 特征缩放</h5><p>在考虑多个特征时，如无特殊需求(可能存在各个特征的权重是不一样的)，我们要保证各个特征的指标值在实际计算时是“公平”的。举一个例子来说，如图2-1多特征的数据集中的房子面积、卧室数量，房子的面积的范围都是超过1000的，而卧室数量则是个位数，那么针对该训练集拟合出的模型更会偏向于房子的面积，也就弱化其他特征的作用。所以，为了保证结果的可靠性，需要对原始数据进行标准化处理。</p><p>特征缩放的方式有很多种（参考我的文章: <a href="https://blog.csdn.net/weixin_42792088/article/details/103971069">数据标准化的常见方法(Min-Max标准化、Z-Score标准化等)</a>），但是都希望缩放后每个特征的范围都是差不多，不然就是白做努力了，如图2-4所示。</p><p><img src="image-20220112171119350.png" alt="图2-4 特征缩放范围"></p><p>在课程中吴恩达老师也介绍一种标准化的方式，如图2-5所示，上述提供我的文章也提供了其他标准化方式，根据实际需求采用。</p><p><img src="image-20220112171422534.png" alt="图2-5 均值归一法"></p><h5 id="2-学习率α"><a href="#2-学习率α" class="headerlink" title="2 学习率α"></a>2 学习率α</h5><p>在梯度下降算法中，需要考虑两个问题:</p><ul><li>“Debugging”: 如何确保梯度下降算法是正确工作的?</li><li>如何选取学习率α?</li></ul><p><strong>确保梯度下降算法正确工作</strong></p><p>一个方法(自动收敛测试,automatic convergence test)就是: 如果两次迭代产生的参数确定的代价函数在训练集上得出的结果减少的幅度是小于或等于<code>ε</code>（可以是 $10^{-3}$，也可以是$10^{-4}$ 等），则说明当前代价函数已经收敛了，此时的参数则是最优的。<strong>但是选取一个合适的阈值时相当困难，所以不采用该方法去判断梯度下降算法是否收敛。</strong></p><p>另一个方法是通过画图展示迭代过程中代价函数的变化过程，最终选取图中函数平缓部分(当图中的曲线趋于平缓时，说明代价函数已经逐渐收敛了)的参数值作为使模型最优的参数,如图2-5所示。<strong>该方法更为直观</strong></p><p><img src="image-20220112174805506.png" alt="图2-5 "></p><p>对于不同的机器学习问题，获得最优模型参数的迭代次数也是不相同的，有可能是30次、3000次甚至于3000000次数等。</p><p><strong>选取学习率α</strong></p><p>在单变量线性回归的部分中已经讲过选取学习率α值过大过小的影响，这里可以通过图示来查看选取不同的α值时代价函数的变化过程，如图2-6所示:</p><p><img src="image-20220112182917833.png" alt="图2-6 "></p><p>针对第一个图1，代价函数的值随着迭代次数的增加而增加，显然没有达到“下降”的作用，即梯度下降算法没有正常工作。那么问题出在哪里呢？<strong>选取了过大的学习率。</strong> 如图3中所示，每次迭代过程中都冲过了最小值。解决方案: 降低学习率的值。</p><p>针对图2，代价函数的值虽然没有随着迭代次数的增加而增加，但它其实也是选取过大的学习率，进而导致θ的选取过程中虽然到了最小的值，但是下一次迭代又因为学习率过大，又跳到曲线的另一侧开始逐渐递增，不断循环往复。。。解决方案还是: 降低学习率的值。</p><p>如果α足够小，$J(θ)$会在每次迭代过程中都会减少，但是如果过小，在梯度下降过程中，收敛速度会异常的缓慢，非常耗费时间。</p><p><strong>总结一下:</strong></p><ul><li>学习率过小: 收敛速度过慢。</li><li>学习率过大:代价函数的值不会在每次迭代都减少；不收敛。</li></ul><p>所以在选取学习率的值时可以这样选(三倍的关系): 0.001、0.003、0.01、0.03、0.1、0.3…</p><h4 id="2-2-多项式回归-polynomial-regression"><a href="#2-2-多项式回归-polynomial-regression" class="headerlink" title="2.2 多项式回归(polynomial regression)"></a>2.2 多项式回归(polynomial regression)</h4><p>在说多项式回归之前，还要简单说一下特征的选取。比如房价预测的问题中，可能提供的特征有纵深和宽度，其假设函数为:</p><script type="math/tex; mode=display">h_θ(x)=θ_0+{θ_1}\times{frontage}+{θ_2}\times{depth}</script><p>我们可以深入思考一下，有必要需要这么参数吗?房子的大小实际上取决于面积，那么面积Area怎么计算?如下:</p><script type="math/tex; mode=display">S_{Area}={frontage}\times{depth}</script><p>那么我们就创建出了一个新的特征，并简化了假设函数:</p><script type="math/tex; mode=display">h_θ(x)=θ_0+{θ_1}\times{S_{Area}}</script><p>所以，当获取到多种特征时，不必都选取所有特征，可以分析训练集的数据分布，根据实际需求选取合适的特征。</p><p>在一些机器学习问题中，如果一味采用线性回归算法去拟合数据，可能得到的模型不太符合实际，就比如图2-7。</p><p><img src="image-20220112192254770.png" alt="图2-7"></p><p>在图中，如果采用线性函数去拟合，那么该函数就不太可能经过大部分点，所以此时要采用多项式函数去拟合。图中考虑了二次的多项式去拟合，但是我们可以知道，该曲线会下降，但常识告诉我们，如果房子大小逐渐变大，房价不可能是会下降的，所以二次多项式模型是不符合的。如果选取三次多项式函数去拟合所构成的模型其效果会好一些，也解决二次多项式去拟合时存在的问题。</p><p>在图中右侧绿色字体给出了在不同次项的size大小范围，可见特征缩放的重要性。</p><p>当然，课程中也提供了另外一个假设函数，也可以适用于上述训练集:</p><script type="math/tex; mode=display">h_θ(x)=θ_0+{θ_1}{(size)}+{θ_2}{(size)^2}</script><h4 id="2-3-正规方程-Normal-Equation"><a href="#2-3-正规方程-Normal-Equation" class="headerlink" title="2.3 正规方程(Normal Equation)"></a>2.3 正规方程(Normal Equation)</h4><p>之前所说的梯度下降算法，为了最小化代价函数$J(θ)$，需要进行多次迭代才能收敛到全局最小值。而正规方程则是<strong>一种求θ的解析解法，不再需要迭代很多次来获得全局最小值，一次即可。</strong></p><p>下面以一个例子直观的去理解该算法，如图2-8:</p><p><img src="image-20220112195410074.png" alt="图2-8"></p><p>针对这样的函数:</p><script type="math/tex; mode=display">J(θ)=aθ^2+bθ+c</script><p>如果要求得其最小值，显然就是求导，然后令其导数为0，解出<code>θ</code>的值即可。</p><p>那么针对代价函数，也可以使用同样的解法，分别对不同的参数求其偏导为0时的值即可得到令代价函数最小的参数值。正规方程便是基于上述思路，只不过计算过程采用了矩阵运算的方式。</p><p>如图2-9所示是利用正规方程去计算<code>θ</code>值的一个例子(其中<code>θ</code>值即为使得代价函数最小的参数值):</p><p><img src="image-20220112200254399.png" alt="图2-9"></p><p><strong>其中，核心计算公式为:</strong></p><script type="math/tex; mode=display">θ=(X^TX)^{-1}X^Ty</script><p>推导过程可参考文章:<a href="https://zhuanlan.zhihu.com/p/60719445">详解正规方程（Normal Equation）</a></p><p><strong>总结一下梯度下降算法与正规方程的优缺点:</strong></p><div class="table-container"><table><thead><tr><th></th><th>梯度下降算法</th><th>正规方程</th></tr></thead><tbody><tr><td>优点</td><td>在特征数量多的时候，该算法依然能够有很好的表现。</td><td>不需要选择学习率α;不需要迭代；</td></tr><tr><td>缺点</td><td>需要选择学习率α；需要多次迭代；</td><td>需要计算$(X^TX)^{-1}$；当特征数量过多时，计算缓慢。</td></tr></tbody></table></div><p><strong>在使用正规方程的过程中，还要注意$X^TX$是否存在可逆矩阵，如果不存在可逆矩阵，该方式也就不能使用了（$X^TX$不可逆即表示其元素存在线性相关，可以尝试删除相关的某一特征或是合并等）。</strong></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
      <tag>人工智能</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux内核学习(二)：内存寻址</title>
    <link href="/2022/01/10/Linux%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%86%85%E5%AD%98%E5%AF%BB%E5%9D%80/"/>
    <url>/2022/01/10/Linux%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%86%85%E5%AD%98%E5%AF%BB%E5%9D%80/</url>
    
    <content type="html"><![CDATA[<blockquote><p>内存管理部分针对的是80x86微处理器如何进行芯片级的内存寻址，Linux又是如何利用寻址硬件的…<span id="more"></span></p></blockquote><h3 id="一、内存地址"><a href="#一、内存地址" class="headerlink" title="一、内存地址"></a>一、内存地址</h3><p><strong>逻辑地址（logical address）：</strong></p><ul><li>包含在机器语言指令中用来指定一个操作数或一条指令的地址。每一个逻辑地址都由一个段（segment）和偏移量（offset）组成，偏移量指明了从段开始的地方到实际地址之间的距离。</li></ul><p><strong>线性地址（linear address）：</strong></p><ul><li>是一个32位无符号整数，可以用来表示高达<code>4GB</code>的地址。通常使用十六进制数组表示，范围从<code>0x00000000</code>到<code>0xffffffff</code>。</li></ul><p><strong>物理地址（phycical address）：</strong></p><ul><li>用于内存芯片级内存单元寻址。物理地址由32位或36位无符号整数表示。</li></ul><p>内存控制单元（<code>MMU</code>）通过一种称为<strong>分段单元（<code>segment unit</code>）的硬件电路</strong>把一个逻辑地址转换成线性地址，接着，第二个称为<strong>分页单元（<code>paging unit</code>）的硬件电路</strong>把线性地址转换为一个物理地址（图1-1表示该过程）。</p><p><img src="image-20211125104204838-16378081303401.png" alt="图1-1"></p><blockquote><p>在多处理系统中，所有CPU都共享同一内存，这意味着RAM芯片可以由独立的CPU并发地访问。由于在RAM芯片上的读或写操作必须串行地执行，因此存在一个内存仲裁器（<code>memory arbiter</code>）的硬件电路插在总线和每个RAM芯片之间，其作用:某个RAM芯片空闲，准予一个CPU访问，如果该芯片忙于为另一个处理器提出的请求服务中，就延迟这个CPU的访问。</p></blockquote><h3 id="二、硬件中的分段"><a href="#二、硬件中的分段" class="headerlink" title="二、硬件中的分段"></a>二、硬件中的分段</h3><blockquote><p>自80286模型开始，Intel微处理器以两种不同的方式执行地址转换，分别为<strong>实模式（real mode） </strong>和<strong>保护模式（protected mode）</strong>。</p></blockquote><h4 id="2-1-段选择符和段寄存器"><a href="#2-1-段选择符和段寄存器" class="headerlink" title="2.1 段选择符和段寄存器"></a>2.1 段选择符和段寄存器</h4><p><strong>逻辑地址的组成：</strong></p><ul><li><p>段标识符</p><ul><li><p>16位长的字段，被称为段选择符（Segment Selector）。</p><ul><li><p>格式：</p><ul><li>索引号指定了放在<code>GDT</code>或<code>LDT</code>中的相应段描述符的入口。</li><li><code>TI</code>指明段描述符是在<code>GDT</code>（TI=0）中还是在<code>LDT</code>中（TI=1）</li><li><code>RPL</code>请求者特权级：当相应段选择符装入到<code>cs</code>寄存器中时指示出CPU当前的特权级，它还可以用于在访问数据段时有选择地削弱处理器的特权级。</li></ul><p><img src="image-20211125110456338.png" alt="图2-1"></p></li></ul></li></ul></li><li><p>指定段内相对地址的偏移量。</p><ul><li>32位长的字段。</li></ul></li></ul><p>在处理器中，存在一些段寄存器用于存放段选择符，一共六个：<code>cs</code>、<code>ss</code>、<code>ds</code>、<code>es</code>、<code>fs</code>、<code>gs</code>。</p><ul><li><code>cs</code>：代码寄存器，指向包含程序指令的段。（另一功能：含有一个两位字段，指明当前CPU的当前特权级，值为0代码最高优先级，而值为3代表最低有限级。Linux只有0级和3级，分别称为内核态和用户态）</li><li><code>ss</code>：栈段寄存器，指向包含当前程序栈的段。</li><li><code>ds</code>：数据段寄存器，指向包含静态数据或全局数据段。</li></ul><p>其余3个作一般用途，可以指向任意的数据段。</p><h4 id="2-2-段描述符"><a href="#2-2-段描述符" class="headerlink" title="2.2 段描述符"></a>2.2 段描述符</h4><blockquote><p>每个段由一个8字节的段描述符（Segment Descriptor）表示，它描述了段的特征。段描述符放在全局描述符表（Global Descriptor Table，<code>GDT</code>）或局部描述符表（Local Descriptor Table，<code>LDT</code>）中。</p></blockquote><p>一般只定义一个<code>GDT</code>，若进程需要创建附加的段可以有自己的<code>LDT</code>。</p><p><strong>段的描述符字段：</strong></p><div class="table-container"><table><thead><tr><th>字段名</th><th>描述</th></tr></thead><tbody><tr><td><code>Base</code></td><td>包含段的首字节的线性地址</td></tr><tr><td><code>G</code></td><td>粒度标志：若该位为0，则段大小以字节为单位，否则以4096字节的倍数计</td></tr><tr><td><code>Limit</code></td><td>存放段中最后一个内存单元的偏移量，从而决定段的长度。如果G被置为0，则一个段的大小在一个字节到1MB之间变化，否则，将在<code>4KB</code>到<code>4GB</code>之间变化。</td></tr><tr><td><code>S</code></td><td>系统标志；如果被清0，则这是一个系统段，存储诸如<code>LDT</code>这种关键的数据结构,否则它是一个普通的代码段或数据段。</td></tr><tr><td><code>Type</code></td><td>描述了段的类型特征和它的存取记录。</td></tr><tr><td><code>DPL</code></td><td>描述符特权级字段：用于限制这个段的存取。它表示为访问这个段而要求的CPU最小的优先级。因此<code>DPL</code>设为0的段只能当<code>CPL</code>为0时（即在内核态）才是可访问的。</td></tr><tr><td><code>P</code></td><td><code>Segment-Present</code>标志:等于0则表示不在主存中。<strong>Linux 总是把这个标志（第47位）</strong>设为1，因为它从来不把整个段交换到磁盘上去。</td></tr><tr><td><code>D</code>or<code>B</code></td><td>称为<code>D</code>或<code>B</code>的标志，取决于时代码段还是数据段。<code>D</code>或<code>B</code>的含义在两种情况下稍微有所区别，如段偏移量的地址为32位，就基本上置其为1.若这个偏移量为16位，则被清0。</td></tr><tr><td><code>AVL</code>标志</td><td>可以由操作系统使用，但是被Linux忽略。</td></tr></tbody></table></div><p><strong>Linux广泛采用的段类型以及它们对应的段描述符：</strong></p><ul><li>代码段描述符<ul><li>表示该段描述符代表一个代码段，它可以放在<code>GDT</code>或<code>LDT</code>中。该描述符置<code>S</code>标志为1。</li></ul></li><li>数据段描述符<ul><li>表示该段描述符代表一个数据段，它可以放在<code>GDT</code>或<code>LDT</code>中。该描述符置<code>S</code>标志为1。栈段通过一般的数据段实现。</li></ul></li><li>任务状态段描述符（<code>TSSD</code>）<ul><li>表示这个段描述符代表一个任务状态段（<code>Task State Segment,Tss</code>），也就是说这个段用于保存处理器寄存器的内容。它只能出现在<code>GDT</code>中，根据相应的进程是否正在CPU上运行，其<code>Type</code>字段的值分别为11或9。该描述符置<code>S</code>标志为0。</li></ul></li><li>局部描述符表描述符（<code>LDTD</code>）<ul><li>表示这个段描述符代表一个包含<code>LDT</code>的段，它只出现在<code>GDT</code>中，相应的<code>Type</code>字段的值为2，<code>s</code>标志置为0.</li></ul></li></ul><p>段描述符的格式如图2-2所示。</p><p><img src="image-20211125151921043-16378247689312.png" alt="图2-2"></p><h4 id="2-3-快速访问段描述符"><a href="#2-3-快速访问段描述符" class="headerlink" title="2.3 快速访问段描述符"></a>2.3 快速访问段描述符</h4><blockquote><p>80x86处理器提供了一种附加的非编程的寄存器（一个不能被程序员所设置的寄存器），供6个可编程的段寄存器使用。</p></blockquote><p>每一个非编程的寄存器含有8个字节的段描述符，由相应的段寄存器中的段选择符来指定。每当一个段选择符被装入段寄存器时，相应的段描述符就由内存装入到对应的非可编程CPU寄存器。所以，<strong>若要针对那个段的逻辑地址转换就可以不访问主存中的<code>GDT</code>或<code>LDT</code>，处理器只需直接引用存放段描述符的CPU寄存器即可。仅当段寄存器的内容改变时，才有必要访问<code>GDT</code>或<code>LDT</code>（参见图2-3）。</strong></p><p><img src="image-20211125153753640-16378258818433.png" alt="图2-3"></p><p>一个段描述符是8字节长，所以它在<code>GDT</code>或<code>LDT</code>内的相对地址是由段选择符的最高13位（索引号）乘以 8得到的。</p><blockquote><p>若<code>GDT</code>在<code>0x00020000</code>（保存在<code>gdtr</code>寄存器中），且由段选择符所指定的索引号为2，那么相应的段描述符地址为<code>0x00020000</code>+（2 x 8）。即<code>0x00020010</code>。<strong><code>GDT</code></strong>的第一项总是设为0，这就确保了空段选择符的逻辑地址会被认为是无效的，因此引发一个处理器异常。</p></blockquote><h4 id="2-4-分段单元"><a href="#2-4-分段单元" class="headerlink" title="2.4 分段单元"></a>2.4 分段单元</h4><p> <strong>逻辑地址转换为相应的线性地址的操作步骤:</strong></p><ol><li>先检查段选择符的<code>TI</code>字段，以决定段描述符保存在哪一个描述符表中。</li><li>从段选择符的<code>index</code>字段计算段描述符的地址。</li><li>把逻辑地址的偏移量与段描述符Base字段的值相加就得到了线性地址。</li></ol><p>图2-4展示了该流程:</p><p><img src="image-20211125200149266-16378417113454.png" alt="图2-4"></p><p><strong>前面说过，80x86处理器提供了不可编程寄存器，故只有当段寄存器的内容被改变时才需要执行前面两个步骤。</strong></p><h3 id="三、Linux中的分段"><a href="#三、Linux中的分段" class="headerlink" title="三、Linux中的分段"></a>三、Linux中的分段</h3><p>实际上，分段和分页都能划分进程的物理空间地址，故在某种程度上这两者显得有点多余。分段可以给每一个进程分配线性地址空间，分页可以把同一线性地址映射不同的物理空间。</p><p>相对于分段，Linux更喜欢分页方式，原因在于:</p><ul><li>如果所有进程使用相同的段寄存器值，内存管理就会变得更简单，即进程之间能够共享同样的一组线性地址。</li><li>RISC体系结构对分段的支持有限，而Linux的设计目标之一是能够移植到绝大数流行的处理器。</li></ul><blockquote><p>注: 2.6版的Linux只有在8086结构下才需要使用分段。</p></blockquote><p>运行在用户态的所有Linux进程都使用一对相同的段对指令和数据寻址。这两个段就是所谓的<strong>用户代码段</strong>和<strong>用户数据段</strong>。类似地，运行在内核态的所有Linux进程也都使用一对相同的段对指令和数据寻址: 一个是 <strong>内核代码段</strong>，另一个是 <strong>内核数据段</strong>。</p><div class="table-container"><table><thead><tr><th style="text-align:center">段</th><th>Base</th><th>G</th><th>Limit</th><th>S</th><th>Type</th><th>DPL</th><th>D/B</th><th>P</th></tr></thead><tbody><tr><td style="text-align:center">用户代码段</td><td>0x00000000</td><td>1</td><td>0xfffff</td><td>1</td><td>10</td><td>3</td><td>1</td><td>1</td></tr><tr><td style="text-align:center">用户数据段</td><td>0x00000000</td><td>1</td><td>0xfffff</td><td>1</td><td>2</td><td>3</td><td>1</td><td>1</td></tr><tr><td style="text-align:center">内核代码段</td><td>0x00000000</td><td>1</td><td>0xfffff</td><td>1</td><td>10</td><td>0</td><td>1</td><td>1</td></tr><tr><td style="text-align:center">内核数据段</td><td>0x00000000</td><td>1</td><td>0xfffff</td><td>1</td><td>2</td><td>0</td><td>1</td><td>1</td></tr></tbody></table></div><p>相应的段选择符由宏<code>__USER_CS</code>(用户代码段)、<code>__USER_DS</code>（用户数据段）、<code>__KERNEL_CS</code>（内核代码段）、<code>__KERNEL_DS</code>（用户数据段）分别定义。例如，若是想要对内核代码段进行寻址，内核只需把<code>__KERNEL_CS</code>产生的值装进<code>cs</code>寄存器即可。</p><p>注意:</p><ul><li>与段相关的线性地址从0开始，达到2<sup> 32</sup> -1的寻址限长。意味着在用户态或内核态下的所有进程可以使用相同的逻辑地址。</li><li>所有段从0x00000000开始，可见，Linux下逻辑地址与线性地址是一致的（逻辑地址的偏移量地段的值与相应的线性地址的值总是一样）。</li><li>CPU的当前特权级(CPL)反映了进程是在用户态还是内核态(CPL=3 用户态，CPL=0 内核态)，并由存放在<code>cs</code>寄存器中的段选择符的<code>RPL</code>字段指定。<strong>只要当前特权级被改变，一些段寄存器必须相应地更新。</strong></li></ul><h4 id="3-1-Linux-中的GDT"><a href="#3-1-Linux-中的GDT" class="headerlink" title="3.1 Linux 中的GDT"></a>3.1 Linux 中的GDT</h4><p><strong>在单处理器中只有一个GDT，而在多处理器系统中每个CPU对应一个GDT。</strong>所有的GDT都存放在<code>cpu_gdt_table</code>数组中，而所有GDT的地址和它们的大小（当初始化gdtr寄存器时使用）被存放在cpu_gdt_descr数组中。</p><p>下图定义于Linux2.6版<code>arch\i386\kernel\head.S</code></p><p><img src="image-20220102161057557.png" alt="image-20220102161057557"></p><blockquote><p>.quad 伪指令: 在存储器中分配<strong>8个字节</strong>，用指定的数据对存储单元进行初始化</p></blockquote><p>每个GDT包含<strong>18个段描述符号</strong>和14个空的，未使用的或保留的项。其中18个段描述符指向的段:</p><ul><li>用户态和内核下的代码段和数据段共4个。</li><li>任务状态段(TSS),每个处理器有1个。</li><li>1个包括缺省局部描述符表的段。</li><li>3个局部线程存储段(Thread-Local Storage,TLS)。</li><li>与高级电源管理(AMP)相关的3个段。</li><li>与支持即插即用(PnP)功能的BIOS服务程序相关的5个段。</li><li>被内核用来处理“双重错误”异常的特殊TSS段。</li></ul><p><strong>注: 系统中每个处理器会有一个GDT副本，除少数几种情况外（如每个处理器有其自己的TSS段），所有GDT的副本都存放相同的表项。</strong></p><h4 id="3-2-Linux中的LDT"><a href="#3-2-Linux中的LDT" class="headerlink" title="3.2 Linux中的LDT"></a>3.2 Linux中的LDT</h4><p>大多数用户态下的Linux程序不使用局部描述符表。在某些情况下，进程若需创建自己的局部描述符表，可以通过<code>modify_ldt()</code>系统调用创建自己的局部描述符表。</p><p>由<code>modify_ldt()</code>系统调用创建的自定义局部描述符表还需要定义属于它自己的段。<strong>当处理器开始执行拥有LDT的进程时，该CPU的GDT副本中的缺省LDT表项会做相应的修改。</strong></p><p>尽管用户态下的程序也利用<code>modify_ldt()</code>来分配新的段，但内核却从不使用这些段，也无需了解相应的段描述符，因为这些段描述符号已经被包含到进程自定义的LDT中了。</p><h3 id="四、硬件中的分页"><a href="#四、硬件中的分页" class="headerlink" title="四、硬件中的分页"></a>四、硬件中的分页</h3><blockquote><p>分页单元(paging unit)把<strong>线性地址</strong>转换为<strong>物理地址</strong>。</p></blockquote><p>注: 如果请求的访问类型与线性地址的访问权限的比较结果为无效，则会产生缺页异常。</p><p><strong>页(page):</strong> 线性地址被分成以固定长度单位的组。</p><p><strong>页表(page table)：</strong> 把线性地址映射到物理地址的数据结构，其存放于主存中。</p><p>页内部连续的线性地址被映射到连续的物理地址中。通常使用术语“页”指一组线性地址，同样也指包含在这组地址中的数据。</p><p>分页单元把所有RAM分成固定长度的页框(page frame)(有时也叫物理页)。每一个页框包含一个页(page),即一个页框的长度与一个页的长度一致。页框是主存的一部分，因此也是一个存储区域。</p><h4 id="4-1-常规分页"><a href="#4-1-常规分页" class="headerlink" title="4.1 常规分页"></a>4.1 常规分页</h4><p>32位的线性地址会被分为3个域:</p><ul><li>Directory(目录): 最高 10位</li><li>Table(页表): 中间10位</li><li>Offset(偏移量): 最低12位</li></ul><p>线性地址的转换分两步完成，每一步都基于一种转换表，第一种转换表称为页目录表(page directory)，第二种转换表称为页表(page table)。使用这种两级模式可以有效地减少每个进程页表所需RAM的数量。</p><p>举例来说，若采用一级页表，如果进程使用全部4GB线性地址空间，那将会需要高达2<sup>20</sup> 个表项来表示每个进程的页表，如果每个表项4个字节，则需要4MB RAM。</p><p>线性地址内的Directory字段决定页目录中的目录项，而目录项指向适当的页表。地址的Table字段依次又决定页表中的表项，而表项含有页所在页框的物理地址。Offset字段决定页框内的相对位置（<strong>由于其是12位长，则每一页可以存放4096字节的数据</strong>）。</p><p><img src="image-20220102174910047.png" alt="80x86处理器的分页"></p><p>页目录项和页表项有同样的结构，每项都包含下面的字段:</p><ul><li>Present 标志<ul><li>如果置为1，所指的页就在主存中；如果该标志位为0，则这一页不在主存中，此时该表项剩余的位可由操作系统用于自己的目的。</li></ul></li><li>包含页框物理地址最高20位的字段<ul><li>每一个页框有4KB的容量，它的物理地址必须是4096的倍数，因此物理地址的最低12位总是为0。若这个字段指向一个页目录，相应的页框就含有一个页表；如果它指向一个页表，相应的页框就含有一页数据。</li></ul></li><li>Accessed标志<ul><li>每当分页单元对相应页框进行寻址时，就设置这个标志。当选中的页被交换出去时，这一标志就可以由操作系统使用。</li></ul></li><li>Dirty标志<ul><li>只应用于页表项中。每当对一个页框进行写操作时就设置这个标志。当选中的页被交换出去时，这一标志就可以由操作系统使用。</li></ul></li><li>Read/Write标志<ul><li>含有页或页表的存取权限(Read/Write或Read)。</li></ul></li><li>User/Supervisor标志<ul><li>含有访问页或页表所需的特权级。</li></ul></li><li>PCD和PWT标志<ul><li>控制硬件高速缓存处理页或页表的方式。</li></ul></li><li>Page Size标志<ul><li>只应用于页目录项。</li></ul></li><li>Global标志<ul><li>只应用于页表项。</li></ul></li></ul><h4 id="4-2-扩展分页"><a href="#4-2-扩展分页" class="headerlink" title="4.2 扩展分页"></a>4.2 扩展分页</h4><blockquote><p>扩展分页允许页框大小为4MB而不是4KB。用于把大段连续的线性地址转换成相应物理地址。</p></blockquote><p><img src="image-20220102180709370.png" alt="image-20220102180709370"></p><p> 分页单元把32位线性地址分成了两个字段:</p><ul><li>Directory: 最高10位</li><li>Offset: 其余22位</li></ul><p>扩展分页和正常分页的页目录项基本相同，除了:</p><ul><li>Page Size 标志必须被设置。</li><li>20位物理地址字段只有最高10位是有意义的。原因在于每一个物理地址都是以4MB为边界的地方开始的，故这个地址的最低22位为0。</li></ul><p>通过设置<code>cr4</code>处理器寄存器的PSE标志能使扩展分页与常规分页共存。</p><h4 id="4-3-64位系统中分页"><a href="#4-3-64位系统中分页" class="headerlink" title="4.3 64位系统中分页"></a>4.3 64位系统中分页</h4><p><strong>32位的微处理器普遍采用两级分页，但两级分页并不适用于64位操作系统的计算机。</strong></p><p>以一个例子解释其原因: 假设存在一个大小为4KB的页，因为1KB覆盖了2<sup>10</sup>地址的范围，4KB则覆盖了2<sup>12</sup>个地址，故offset字段是12位。这样线性地址就还剩52位可以分给Table和Directory字段。如果限制仅仅使用64位中的48位来寻址（依然能有256TB的寻址空间），则还有36位可以分配给Table和Directory字段。若平分36位给这两个字段，那么每个进程的页目录和页表项都含有2<sup>18</sup>个项，即超过256000个项。<strong>数量太多了!</strong></p><p>因此，所有64位处理器的硬件分页系统都使用了额外的分页级别，使用的级别数量取决于处理器的类型。如图所示:</p><p><img src="image-20220110152953475.png" alt="1"></p><p><img src="image-20220110153015762.png" alt="2"></p><h4 id="4-4-硬件高速缓存与转换后援缓冲器-TLB"><a href="#4-4-硬件高速缓存与转换后援缓冲器-TLB" class="headerlink" title="4.4 硬件高速缓存与转换后援缓冲器(TLB)"></a>4.4 硬件高速缓存与转换后援缓冲器(TLB)</h4><p>如今的微处理器时钟频率接近几个GHz,而动态RAM(DRAM)芯片的存取时间是时钟周期的数百倍。这意味着，当从RAM中取操作数或向RAM中存放结果这样的指令执行时，CPU可能等待很长时间。</p><p><strong>引入硬件高速缓存内存(hardware cache memory)是为了缩小CPU和RAM之间的速度不匹配。</strong></p><p>硬件高速缓存内存基于著名的局部性原理(Locality principle)，该原理既适用程序结构和数据结构。这表明由于程序的循环结构以及相关数组可以组织成线性数组，最近最常用的相邻地址在最近的将来又被用到的可能性极大。故引入小而快的内存来存放最近最常使用的代码和数据变得很有意义。</p><p>8086体系结构中的”行”: 由几十个连续的字节组成，以脉冲突发模式(burst mode)在慢速DRAM和快速的用来实现高速缓存的片上静态RAM(SRAM)之间传送，用来实现高速缓存。</p><p>高速缓存单元插在分页单元和主内存之间，它包含一个硬件高速缓存内存(hardware cache memory)和一个高速缓存控制器(cache controller):</p><ul><li>高速缓存内存:存放内存中真正的行。</li><li>高速缓存控制器: 存放一个表项数组，每个表项对应高速缓存内存中的一个行。</li></ul><p><img src="image-20220110161733787.png" alt="处理器硬件高速缓存"></p><p>当访问一个RAM存储单元时，CPU从物理地址中提取出子集的索引号并把子集中所有行的标签与物理地址的高几位相比较，若发现某一行的标签与这个物理地址的高位相同，则CPU命中一个高速缓存(Cache hit)，否则，高速缓存没有命中。</p><p>当命中一个高速缓存时，高速缓存控制器进行不同的操作，具体取决于存取类型：</p><ul><li>读操作: 控制器从高速缓存行中选择数据并送到CPU寄存器，不需要访问RAM因而节约了CPU时间，因此高速缓存系统起到了其应有的作用。</li><li>写操作: 控制器可能采用以下两种基本策略之一。<ul><li>通写(write-through): 既写RAM也写高速缓存行。</li><li>回写(write-back): 只更新高速缓存行，不改变RAM的内容，提供了更快的功效。注：回写结束以后，RAM最终必须被更新（当CPU执行一条要求刷新高速缓存表项的指令时，或者当一个FLUSH硬件信号产生时，高速缓存控制器才把高速缓存行写回到RAM中）。</li></ul></li></ul><p>如果高速缓存没有命中，高速缓存行被写回到内存中，如果有必要的话，可以把正确的行从RAM中取出放到高速缓存的表项。</p><p><strong>多处理器系统的每一个处理器都有一个单独的硬件高速缓存，因此它们需要额外的硬件电路用于保持高速缓存内容的同步。</strong></p><p>除了通用硬件高速缓存之外，<strong>8086处理器还包含可另一个称为转换后援缓冲器或TLB(Translation Lookaside Buffer)的高速缓存用于加快线性地址的转换</strong>。当一个线性地址被第一次使用时，通过慢速访问RAM中的页表计算出相应的物理地址。同时，<strong>物理地址被存放在一个TLB表项(TLB entry)中</strong>，以便以后对同一个线性地址的引用可以快速得到转换。</p><p><strong>在多处理器系统中，每个CPU都有自己的TLB，这叫做该CPU的本地TLB。与硬件高速缓存相反，TLB中的对应项不必同步，这是因为运行在现有CPU上的进程可以使同一线性地址与不同的物理地址发生联系。</strong></p><h3 id="五、Linux中的分页"><a href="#五、Linux中的分页" class="headerlink" title="五、Linux中的分页"></a>五、Linux中的分页</h3><p>Linux采用了一种同时适用于32位和64位系统的普通分页模型。两级页表对于32位系统来说是足够的，但是对于64位操作系统还是不够的。Linux 2.6.10版采用三级分页模型，自2.6.11版本开始，采用了四级分页模型:</p><ul><li>页全局目录(Page Global Directory)</li><li>页上级目录(Page Upper Directory)</li><li>页中间目录(Page Middle Directory)</li><li>页表(Page Table)</li></ul><p>页全局目录包含若干页上级目录，页上级目录又依次包含若干页中间目录的地址，而页中间目录又包含若干页表的地址。如图表示其分页模式:</p><p><img src="image-20220110171801334.png" alt="分页模式"></p><p>Linux通过使”页上级目录”位和“页中间目录”位全为0，从根本上取消了页上级目录和页中间目录字段。为了能够保证同样的代码在32位系统和64位系统下都能使用，页上级目录和页中间目录在指针序列中的位置被保留。</p><p>线性地址到物理地址的自动转换使下面的设计目标变得可行:</p><ul><li>给每一个进程分配一块不同的物理地址空间，这确保了可以有效地防止寻址错误。</li><li>区别页（即一组数据）和页框（即主存中的物理地址）之不同。允许存放在某个页框中的一个页，保存到磁盘上，以后重新装入这同一页时又可以被装在不同的页框中。</li></ul><h4 id="5-1-物理内存布局"><a href="#5-1-物理内存布局" class="headerlink" title="5.1 物理内存布局"></a>5.1 物理内存布局</h4><p>内核将下列页框记为保留:</p><ul><li>在不可用的物理地址范围内的页框。</li><li>含有内核代码和已初始化的数据结构的页框。</li></ul><p><strong>保留页框中的页绝不能被动态分配或交换到磁盘上。</strong></p><p>一般来说，Linux内核安装在RAM中从物理地址<strong>0x00100000</strong>开始的地方，即从第二个MB开始。所需页框总数依赖于内核的配置方案，典型的配置所得到的内核可以被安装在小于3MB的RAM中。</p><p>之所以内核没有安装在RAM第一个MB开始的地方在于:</p><ul><li>页框0由BIOS使用，存放加电自检(Power-On Self-Test,POST)期间检查到的系统硬件配置。</li><li>物理地址从0x000a0000到0x000fffff的范围通常留给BIOS例程，并且映射ISA图形卡上的内部内存。</li><li>第一个MB内的其他页框可能由特定计算机模型保留。</li></ul><p>在启动过程的早期阶段，内核询问BIOS并了解物理内存的大小。在新近的计算机中，内核也调用BIOS过程建立一组物理地址范围和其对应的内存类型。随后，内核执行<code>machine_specific_memory_setup()</code>函数，该函数建立物理地址映射。</p><h4 id="5-2-进程页表"><a href="#5-2-进程页表" class="headerlink" title="5.2 进程页表"></a>5.2 进程页表</h4><p>进程的线性地址空间分成两部分:</p><ul><li>从0x00000000到0xbfffffff的线性地址，无论进程运行在用户态还是内核态都可以寻址。</li><li>从0xc0000000到0xffffffff的线性地址，只有内核态的进程才能寻址。</li></ul><p>即进程运行在用户态时，它产生的线性地址小于0xc0000000;当进程运行在内核态时，它执行内核代码，所产生的地址大于等于0xc0000000。在某些情况下，内核为了检索或存放数据必须访问用户态线性空间地址。</p><p><strong>宏PAGE_OFFSET产生的值是0xc0000000，这就是进程在线性地址空间中的偏移量，也是内核生存空间的开始之处。</strong></p><p>内核初始化页表的过程:</p><ol><li>内核创建一个有限的地址空间，包括内核的代码段和数据段、初始页表和用于存放动态数据结构的共128KB大小的空间。这个最小限度的地址空间仅够将内核装入RAM和对其初始化的核心数据结构。</li><li>内核充分利用剩余的RAM并适当地建立分页表。</li></ol><h4 id="5-3-固定映射的线性地址"><a href="#5-3-固定映射的线性地址" class="headerlink" title="5.3 固定映射的线性地址"></a>5.3 固定映射的线性地址</h4><p>内核线性地址第四个GB的初始部分映射系统的物理内存，但至少128MB的线性地址总是留作他用，因为内核使用这些线性地址实现非连续内存分配（仅仅是动态分配和释放内存页的一种特殊方式）和固定映射的线性地址。</p><p>内核使用固定映射的线性地址来代替指针变量，因为这些指针变量的值从不改变（实际上，间接引用一个指针变量比间接引用一个立即常量地址要多一次内存访问。）。固定映射的线性地址可以映射任何物理地址，而由第4GB初始部分的线性地址所建立的映射是线性的（线性地址X映射物理地址X-PAGE_OFFSET）。</p><p>每个固定映射的线性地址都由定义于enum fixed_addresses数据结构中的整型索引来表示:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">fixed_addresses</span> &#123;</span><br>FIX_HOLE,<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Reserve a virtual window for the FDT that is 2 MB larger than the</span><br><span class="hljs-comment"> * maximum supported size, and put it at the top of the fixmap region.</span><br><span class="hljs-comment"> * The additional space ensures that any FDT that does not exceed</span><br><span class="hljs-comment"> * MAX_FDT_SIZE can be mapped regardless of whether it crosses any</span><br><span class="hljs-comment"> * 2 MB alignment boundaries.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Keep this at the top so it remains 2 MB aligned.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FIX_FDT_SIZE(MAX_FDT_SIZE + SZ_2M)</span><br>FIX_FDT_END,<br>FIX_FDT = FIX_FDT_END + FIX_FDT_SIZE / PAGE_SIZE - <span class="hljs-number">1</span>,<br><br>FIX_EARLYCON_MEM_BASE,<br>FIX_TEXT_POKE0,<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> CONFIG_ACPI_APEI_GHES</span><br><span class="hljs-comment">/* Used for GHES mapping from assorted contexts */</span><br>FIX_APEI_GHES_IRQ,<br>FIX_APEI_GHES_NMI,<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span> <span class="hljs-comment">/* CONFIG_ACPI_APEI_GHES */</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> CONFIG_UNMAP_KERNEL_AT_EL0</span><br>FIX_ENTRY_TRAMP_DATA,<br>FIX_ENTRY_TRAMP_TEXT,<br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TRAMP_VALIAS(__fix_to_virt(FIX_ENTRY_TRAMP_TEXT))</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span> <span class="hljs-comment">/* CONFIG_UNMAP_KERNEL_AT_EL0 */</span></span><br>__end_of_permanent_fixed_addresses,<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Temporary boot-time mappings, used by early_ioremap(),</span><br><span class="hljs-comment"> * before ioremap() is functional.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NR_FIX_BTMAPS(SZ_256K / PAGE_SIZE)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FIX_BTMAPS_SLOTS7</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TOTAL_FIX_BTMAPS(NR_FIX_BTMAPS * FIX_BTMAPS_SLOTS)</span><br><br>FIX_BTMAP_END = __end_of_permanent_fixed_addresses,<br>FIX_BTMAP_BEGIN = FIX_BTMAP_END + TOTAL_FIX_BTMAPS - <span class="hljs-number">1</span>,<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Used for kernel page table creation, so unmapped memory may be used</span><br><span class="hljs-comment"> * for tables.</span><br><span class="hljs-comment"> */</span><br>FIX_PTE,<br>FIX_PMD,<br>FIX_PUD,<br>FIX_PGD,<br><br>__end_of_fixed_addresses<br>&#125;;<br></code></pre></td></tr></table></figure><p>每个固定映射的线性地址都存放在线性地址第四个GB的末端。</p><h4 id="5-4-处理硬件高速缓存与TLB"><a href="#5-4-处理硬件高速缓存与TLB" class="headerlink" title="5.4 处理硬件高速缓存与TLB"></a>5.4 处理硬件高速缓存与TLB</h4><p><strong>处理硬件高速缓存</strong></p><p>硬件高速缓存是通过高速缓存行(cache line)寻址的。L1_CACHE_BYTES宏产生以字节为单位的高速缓存行的大小。</p><p>为了使高速缓存的命中率达到最优化，内核在下列决策中考虑体系结构:</p><ul><li>一个数据结构中最常使用的字段放在该数据结构内的低偏移部分，以便它们能够处于高速缓存的同一行中。</li><li>当为一大组数据结构分配空间时，内核试图把它们都放在内存中，以便所有高速缓存行按同一方式使用。</li></ul><p><strong>处理TLB</strong></p><p>处理器不能自动同步它们自己的TLB高速缓存，因为决定线性地址和物理地址之间的映射何时不在有效的<strong>是内核</strong>，而<strong>不是硬件</strong>。</p><p>一般来说，任何进程切换都会暗示着更换活动页表集。相对于过期页表，本地TLB表项必须被刷新，这个过程在内核把新的页全局目录的地址写入cr3控制寄存器时会自动完成。</p><p>内核在下列情况将避免TLB被刷新:</p><ul><li>当两个使用相同页表集的普通进程之间执行进程切换时。</li><li>当在一个普通进程和一个内核线程间执行进程切换时。</li></ul><p>每个内核线程并不拥有自己的页表集，更确切地说，它使用一个普通进程的页表集。</p><p>当某个CPU开始运行一个内核线程时，内核把它置为懒惰TLB模式。当发出清除TLB表项的请求时，处于懒惰TLB模式的每个CPU都不刷新相应的表项，但是，CPU记住它的当前进程正运行在一组页表上，而这组页表的TLB表项对用户态地址是无效的。只要处于懒惰TLB模式的CPU用一个不同的页表集切换到一个普通的线程，硬件就自动刷新TLB表项，同时内核把CPU设置为非懒惰TLB模式。<strong>若处于懒惰TLB模式的CPU切换到的进程与刚才运行的内核线程拥有相同的页表集，那么，任何使TLB无效的延迟操作必须由内核有效地实施。</strong></p><p>为了实现懒惰TLB模式，需要一些额外的数据结构。<code>cpu_tlbstate</code>变量是一个具有<code>NR_CPUS</code>（这个宏的默认值为32，它代表了系统中CPU的最大数量）个结构的静态数组，该结构有两个字段，一个是指向当前进程内存描述符的<code>active_mm</code>字段，一个是具有两个状态值的state字段: <code>TLBSTATE_OK</code>(非懒惰TLB模式)或<code>TLBSTATE_LAZY</code>(懒惰TLB模式)。每个内存描述符包含一个<code>cpu_vm_mask</code>字段，该字段存放的是CPU（这些CPU将要接收与TLB刷新相关的处理器间中断）下标，当然，只有当内存描述符属于当前运行的一个进程时这个字段才有意义。</p><p>当一个CPU开始执行内核线程时，内核把该CPU的<code>cpu_tlbstate</code>元素的<code>state</code>字段置为<code>TLBSTATE_LAZY</code>,此外，活动内存描述符的<code>cpu_vm_mask</code>字段存放系统中所有CPU下标。</p><p>对于给定页表集相关的所有CPU的TLB表项，当另外一个CPU想使这些表项无效时，该CPU就把一个处理器间中断发送给下标处于对应内存描述符的<code>cpu_vm_mask</code>字段中的那些CPU。</p><p>当CPU接收到一个与TLB刷新相关的处理器间中断，并验证它影响了其当前进程的页表集时，它就检查它的<code>cpu_tlbstate</code>元素的<code>state</code>字段是否等于<code>TLBSTATE_LAZY</code>。若等于，内核就拒绝使TLB表项无效，并从内存描述符的<code>cpu_vm_mask</code>字段删除该CPU下标。这有两种结果:</p><ul><li>只要CPU还处于懒惰TLB模式，它将不接受其他与TLB刷新相关的处理器间中断。</li><li>如果CPU切换到另一个进程，而这个进程与刚被替换的内核线程使用相同的页表集，那么内核调用__flush_tlb()使该CPU的所有非全局TLB表项无效。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>吴恩达机器学习笔记1: 何为机器学习</title>
    <link href="/2022/01/06/%E5%90%B4%E6%81%A9%E8%BE%BE%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01-%E4%BD%95%E4%B8%BA%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    <url>/2022/01/06/%E5%90%B4%E6%81%A9%E8%BE%BE%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01-%E4%BD%95%E4%B8%BA%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<blockquote><p>机器学习是目前信息技术中最激动人心的方向之一，本文为学习吴恩达的机器学习课程后所做的笔记。<span id="more"></span></p></blockquote><h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h3><p>在我们的日常生活中都在不知不觉使用了机器学习的算法数次，如使用谷歌、百度获取个人所需的内容，使用电子邮件垃圾筛选器，知乎上的个性化推荐等等。机器学习受欢迎的原因不仅在于它在人工智能领域的应用，它还涉及了各个行业和基础科学，如机器人、计算生物学等。</p><p><strong>一些机器学习的案例</strong></p><ul><li><strong>数据库挖掘(Database mining)：</strong>大量的数据集来源于网络与自动化技术的增长，如来源于Web点击数据，医疗记录，计算生物学，工程方面的数据等。</li><li><strong>应用程序不能手动编程(Application can’t program by hand):</strong> 自主直升机、手写识别、大部分NLP、计算机视觉等。</li><li><strong>自定制程序(Self-customizing programs):</strong> 亚马逊、网飞的产品推荐等。</li><li><strong>理解人类学习(大脑)</strong></li></ul><h3 id="2-机器学习定义"><a href="#2-机器学习定义" class="headerlink" title="2 机器学习定义"></a>2 机器学习定义</h3><p><strong>Arthur Samuel(1959): </strong> Field of study that gives computers the ability to learn  without being explicitly programmed 。</p><blockquote><p>译: 在没有明确编程下，让计算机具有学习能力的研究领域。</p></blockquote><p><strong>Tom Mitchell(1998): </strong>A computer program is said to learn from experience E with respect to some task T and some performance measure P, if its  performance on T, as measured by P, improves  with experience E。</p><blockquote><p>译: 一个程序被认为能从经验E中学习，解决任务T，达到性能度量值P，当且仅当，有了经验E后经过P评判，程序在处理T时的性能有所提升。</p></blockquote><p><img src="image-20220106160317350.png" alt="图1"></p><p>机器学习算法主要分为两大类:</p><ul><li>监督学习：教计算机如何去完成任务。</li><li>无监督学习：让计算机自己学习。</li></ul><p>其他类型: 强化学习、推荐系统。 </p><h3 id="3-监督学习-Supervised-Learning"><a href="#3-监督学习-Supervised-Learning" class="headerlink" title="3 监督学习(Supervised Learning)"></a>3 监督学习(Supervised Learning)</h3><blockquote><p> <strong>定义:</strong> 根据<strong>已有的数据集(包含正确的结果)</strong>，知道输入和输出结果之间的关系。根据这种已知的关系，训练得到一个最优的模型</p></blockquote><h4 id="3-1-回归-Regression"><a href="#3-1-回归-Regression" class="headerlink" title="3.1 回归(Regression)"></a>3.1 回归(Regression)</h4><p>如图2所示是来自于某个研究所收集的房价数据，横轴表示房子的面积（单位为平方英尺），纵轴表示房价（单位为千美元）。基于这一组数据，假如有一个朋友有一套750平方英尺的房子，现在他希望把房子卖掉，并且他想知道这房子能卖多少钱?</p><p><img src="image-20220106161139777.png" alt="图2-房价预测"></p><p>试想一下，机器学习算法将会如何帮助我们?（根据数据集采用不同的曲线去拟合，以便达到最优模型）</p><ol><li>在这组数据中画一条直线，可以估计这套房子能卖$150,000</li><li>使用二次方程去拟合，可以估计这套房子能卖$200,000</li><li>…等</li></ol><p>上述预测房价的这个问题可以归为<strong>回归问题</strong>，尽管房价实际上是一系列离散的值，但是通常我们又把房价看成是一个连续的数值。</p><p><strong>回归:</strong> 预测连续值输出（即预测的值是连续的，如房价）。</p><h4 id="3-2-分类-Classification"><a href="#3-2-分类-Classification" class="headerlink" title="3.2 分类(Classification)"></a>3.2 分类(Classification)</h4><p>假设我们打算通过查看病历去推测乳腺癌良性与否，有这样一组数据：在这个数据集里面，横轴表示肿瘤大小，纵轴的1和0表示是或者不是恶性肿瘤。如图3，有5个良性的肿瘤样本和5个恶性肿瘤样本在图中标出（图3提供了两种不同的绘制图的方式）。</p><p><img src="image-20220106165157945.png" alt="图3-乳腺肿瘤样本图"></p><p>假设有这样的一个人，不幸检查出了乳腺肿瘤，并知道其大小，现在机器学习的问题在于，能否估算出该肿瘤是恶性的还是良性？这是一个<strong>分类问题</strong>。</p><p><strong>分类: </strong>预测离散的输出值。</p><p>在分类问题中，也有可能输出多个值，但这也是属于分类问题。</p><p>在现实例子中，可能遇到的不止一种特征，如在肿瘤问题中，不仅了解到肿瘤的尺寸，还了解对应患者的年龄，也可能还有 肿块密度、肿瘤细胞尺寸的一致性和形状的一致性等，如图4所示。在实际的算法处理中，我们可能更希望能够利用更多特征，而存储这些特征可能会导致内存的不够用，该问题可以通过后续的<strong>支持向量机</strong>算法中的某个技巧去解决。</p><p><img src="image-20220106170229091.png" alt="图4-多特征的肿瘤数据"></p><p>下面是一个小测验，如图5所示。</p><p><img src="image-20220106170845235.png" alt="图5-测验"></p><p><strong>问题1是一个回归问题:</strong> 货物的数量可以看作一个实数，连续的值，相对的，卖出去的物品数目也可以看作是连续值。</p><p><strong>问题2是一个分类问题: </strong> 需要判断的是账户是否被盗，而可以使用0和1分别表示被盗与否，这个输出的值属于离散值。</p><h3 id="4-无监督学习-Unsupervised-Learning"><a href="#4-无监督学习-Unsupervised-Learning" class="headerlink" title="4 无监督学习(Unsupervised Learning)"></a>4 无监督学习(Unsupervised Learning)</h3><blockquote><p>相比于监督学习，无监督学习中的数据集并不会提供标签或者是有相同的标签，学习算法需要从该数据集中根据数据的结构去进行分类。如图5所示，无监督学习能够判断出数据有两个不同的聚集簇，所以它叫做聚类算法。</p></blockquote><p><img src="无监督学习.png" alt="图5-无监督学习"></p><p>聚类算法和无监督学习算法也可以用在其他问题上，如基因学的理解应用，其思想是输入一组不同的个体，对于其中的个体，需要分析出它们是否具有一个特定的基因。如图6所示，不同颜色都展示个体在基因表达方面的程度，需要做的就是采用聚类算法把个体聚类到不同的类或不同类型的组。</p><p><img src="image-20220106194219314.png" alt="图6-个体基因表达图"></p><p>聚类还可以有其他应用场景，如图7所示。</p><p><img src="image-20220106195228530.png" alt="图7-聚类的其他应用场景"></p><p>聚类只是无监督学习中的一种，另外一种的应用场景如图8所示，即<strong>鸡尾酒宴问题</strong>。</p><p><img src="image-20220106195500137.png" alt="图8-鸡尾酒宴问题"></p><p>所谓鸡尾酒宴问题，就是在一个满是人的房间里，都在互相交谈，声音彼此重叠，对相对而坐的两个人来说，有可能互相之间听不到对方在说什么。现在把问题简化为两个人坐在同一个房间里，里面放置着两个麦克风，距离不同，让两个人同时说话，如图8。这样每个麦克风就记录下了两者一起说话的声音。现在，可以使用无监督学习算法，将它们区分开来。</p><p>对于初学者来说，这个无监督学习算法感觉实现起来有点复杂（<del>没错，就是我了</del>）。但由研究人员花了大量时间得出的代码却是相当的简单:</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs matlab">[W,s,v] = svd((<span class="hljs-built_in">repmat</span>(sum(x.*x,<span class="hljs-number">1</span>),<span class="hljs-built_in">size</span>(x,<span class="hljs-number">1</span>),<span class="hljs-number">1</span>).*x)*x&#x27;);<br></code></pre></td></tr></table></figure><p>一个小测验，如图9所示。</p><p><img src="image-20220106201048218.png" alt="图9-无监督学习测验"></p><p>下面分析四个选项:</p><ol><li>这个是垃圾邮件分类问题，是一个<strong>监督学习问题</strong>（提供了标记好的数据集供学习）。</li><li>这个是新闻分类的问题，这个属于<strong>无监督学习问题</strong>，主要是通过根据不同文章的内容，相似的便聚到一起。</li><li>这个是细分市场问题，这个可以看作是<strong>无监督学习问题</strong>，主要是根据数据让算法进一步细分市场。</li><li>这个是糖尿病问题，类似于上文说到的乳腺癌问题，提供了已经标记的好的数据集（标记患者是否患糖尿病），所以它是<strong>监督学习问题</strong>。</li></ol>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
      <tag>人工智能</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>为虚拟机下的ubuntu-1804配置静态ip</title>
    <link href="/2022/01/05/%E4%B8%BA%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%8B%E7%9A%84ubuntu-1804%E9%85%8D%E7%BD%AE%E9%9D%99%E6%80%81ip/"/>
    <url>/2022/01/05/%E4%B8%BA%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%8B%E7%9A%84ubuntu-1804%E9%85%8D%E7%BD%AE%E9%9D%99%E6%80%81ip/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文将提供两种方法(netplan、interfaces)为虚拟机下的Ubuntu-1804系统配置静态ip地址…</p></blockquote><span id="more"></span><h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>  因为作者在本地搭建了一个虚拟机，并安装了Ubuntu-1804用于一些日常分析Linux下的程序。因为这个缘故，常常需要使用在主机下使用vscode远程连接虚拟机。但是虚拟机的ip地址如果不是静态的，时不时它会自动分配一个新的ip地址，这时就得重新配置主机下一些远程连接的配置文件，次数多了就感觉麻烦了。</p><p>使用的虚拟机平台: <strong>VMware® Workstation 16 Pro</strong></p><h3 id="二、获取基本参数"><a href="#二、获取基本参数" class="headerlink" title="二、获取基本参数"></a>二、获取基本参数</h3><p>打开VMware上栏 编辑-&gt;虚拟网络编辑器 选项，打开后如图1所示（如果是和我一样灰色的，点击《更改设置》获取权限即可。）。</p><p><img src="image-20220105161805434.png" alt="图1-虚拟网络编辑器1"></p><p>当页面不再是灰色之后，如图2所示，依次按步骤操作。</p><p><img src="image-20220105162130468.png" alt="图2-虚拟网络编辑器2"></p><p>最终打开的界面如图3所示，可获得子网掩码，网关ip（<strong>这两者在读者和作者的电脑上不是都一样的，记下来即可</strong>）。</p><p><img src="image-20220105162302719.png" alt="图3-NAT设置"></p><h3 id="三、配置静态ip"><a href="#三、配置静态ip" class="headerlink" title="三、配置静态ip"></a>三、配置静态ip</h3><h4 id="3-1-查看网卡"><a href="#3-1-查看网卡" class="headerlink" title="3.1 查看网卡"></a>3.1 查看网卡</h4><p>执行下面的命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ifconfig<br></code></pre></td></tr></table></figure><p>界面信息如图4所示</p><p><img src="image-20220105163000728.png" alt="图4-ifconfig信息"></p><p>可知网卡的设备名此处为 ens33，待会配置的时候也是按照这个来进行配置。</p><h4 id="3-2-方法1-使用netplan配置静态ip"><a href="#3-2-方法1-使用netplan配置静态ip" class="headerlink" title="3.2 方法1: 使用netplan配置静态ip"></a>3.2 方法1: 使用netplan配置静态ip</h4><p><strong>1. 进入/etc/netplan目录</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment"># 进入目录</span></span><br>cd /etc/netplan  <br><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment"># 列出配置文件</span></span><br>ls<br></code></pre></td></tr></table></figure><p>界面如图5所示(像作者的界面展示的yaml文件名则为<code>01-network-manager-all.yaml</code> ，你的可能是<code>xxxxx.yaml</code>格式的)。</p><p><img src="image-20220105163824253.png" alt="图5-/etc/netplan"></p><p><strong>2.编辑配置文件</strong></p><p>执行如下命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> xx的具体内容依据你本地文件名称</span><br>sudo vim xx.yaml <br></code></pre></td></tr></table></figure><p>打开内容</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># Let NetworkManager manage all devices on this system</span><br><span class="hljs-attr">network:</span><br><span class="hljs-comment"># 下面这部分一般来说是自己添加的</span><br>  <span class="hljs-comment">#######################################################################</span><br>  <span class="hljs-attr">ethernets:</span><br>          <span class="hljs-attr">ens33:</span><br>                  <span class="hljs-attr">addresses:</span> [<span class="hljs-number">192.168</span><span class="hljs-number">.122</span><span class="hljs-number">.220</span><span class="hljs-string">/24</span>] <span class="hljs-comment">#你需要配置的ip地址以及对应的掩码 /24 相当于 255.255.255.0</span><br>                  <span class="hljs-attr">dhcp4:</span> <span class="hljs-literal">no</span>  <span class="hljs-comment"># 不需要dhcp4，静态ip</span><br>                  <span class="hljs-attr">optional:</span> <span class="hljs-literal">true</span><br>                  <span class="hljs-attr">gateway4:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.122</span><span class="hljs-number">.2</span> <span class="hljs-comment"># 网关地址，上面获取基本参数获得</span><br>                  <span class="hljs-attr">nameservers:</span><br>                          <span class="hljs-attr">addresses:</span> [<span class="hljs-number">114.114</span><span class="hljs-number">.114</span><span class="hljs-number">.144</span>,<span class="hljs-number">8.8</span><span class="hljs-number">.8</span><span class="hljs-number">.8</span>]   <span class="hljs-comment">#dns服务器，配置多个时，使用英文逗号隔开</span><br>   <span class="hljs-comment">##########################################################################</span><br>  <span class="hljs-attr">version:</span> <span class="hljs-number">2</span><br>  <span class="hljs-attr">renderer:</span> <span class="hljs-string">NetworkManager</span><br><br></code></pre></td></tr></table></figure><p><strong>3. 配置生效</strong></p><p>执行如下命令，可使配置生效。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo netplan apply<br></code></pre></td></tr></table></figure><p><strong>4.查看ip是否更新以及访问外网测试</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">ifconfig<br><span class="hljs-meta">#</span><span class="bash"> ping外网测试</span><br>ping www.baidu.com<br></code></pre></td></tr></table></figure><p>如果展示类似如下信息，则说明网络能够正常访问（第一次设置，可能第一次ping不通，可以试试晚点再ping）,即静态ip已经成功配置。</p><blockquote><p>64 bytes from 103.235.46.39 (103.235.46.39): icmp_seq=1 ttl=128 time=57.0 ms<br>64 bytes from 103.235.46.39 (103.235.46.39): icmp_seq=2 ttl=128 time=84.6 ms<br>64 bytes from 103.235.46.39 (103.235.46.39): icmp_seq=3 ttl=128 time=57.3 ms<br>64 bytes from 103.235.46.39 (103.235.46.39): icmp_seq=4 ttl=128 time=55.9 ms<br>64 bytes from 103.235.46.39 (103.235.46.39): icmp_seq=5 ttl=128 time=56.2 ms<br>64 bytes from 103.235.46.39 (103.235.46.39): icmp_seq=6 ttl=128 time=55.7 ms</p><p>…</p></blockquote><h4 id="3-2-方法2-使用interfaces配置静态ip"><a href="#3-2-方法2-使用interfaces配置静态ip" class="headerlink" title="3.2 方法2: 使用interfaces配置静态ip"></a>3.2 方法2: 使用interfaces配置静态ip</h4><blockquote><p>该方法不推荐，特别是还得再去修改其他文件去配置dns服务器ip地址（尽管其他博文有说可以在interfaces文件进行配置，但是我并没有配置生效过，在此就不举例了）</p></blockquote><p><strong>1.打开配置文件 /etc/network/interfaces,新增如下内容</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> interfaces(5) file used by ifup(8) and ifdown(8)</span><br>auto lo<br>iface lo inet loopback<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">####################下面是新增的#########################</span></span><br><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment"># ens33 是网卡设备名称，如3.1获取到的一致</span></span><br>auto ens33<br>iface ens33 inet static<br>address 192.168.122.35 ## 配置的静态ip地址<br>netmask 255.255.255.0 ## 掩码<br>gateway 192.168.122.2 ## 网关<br></code></pre></td></tr></table></figure><p>执行下面命令，重启网卡</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo service networking stop<br>sudo service networking start<br><span class="hljs-meta">#</span><span class="bash">或者(这个我试的时候没有生效)</span><br>sudo service networking restart<br><br></code></pre></td></tr></table></figure><p>查看一下ip是否更新</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ifconfig<br></code></pre></td></tr></table></figure><p><strong>如果没有更新的话，只能重启虚拟机了。</strong></p><p><strong>2.打开配置文件 /etc/systemd/resolved.conf，新增dns解析服务器ip地址</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">[Resolve]<br>DNS=8.8.8.8 # 新增<br>DNS=114.114.114.114 #新增<br><span class="hljs-meta">#</span><span class="bash">FallbackDNS=</span><br><span class="hljs-meta">#</span><span class="bash">Domains=</span><br><span class="hljs-meta">#</span><span class="bash">LLMNR=no</span><br><span class="hljs-meta">#</span><span class="bash">MulticastDNS=no</span><br><span class="hljs-meta">#</span><span class="bash">DNSSEC=no</span><br><span class="hljs-meta">#</span><span class="bash">Cache=yes</span><br><span class="hljs-meta">#</span><span class="bash">DNSStubListener=yes</span>                                                                                                                                     <br></code></pre></td></tr></table></figure><p>执行下面命令，重启服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo service systemd-resolved restart<br></code></pre></td></tr></table></figure><p>这时再ping一下<code>www.baidu.com</code>应该是没有什么问题了。</p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="https://cloud.tencent.com/developer/article/1830976">Ubuntu 18.04 永久修改DNS的方法</a></li><li><a href="https://ld246.com/article/1593929878472">ubuntu 20.04 server 版设置静态 IP 地址</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ubuntu</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Makefile学习笔记</title>
    <link href="/2022/01/01/makefile%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/01/01/makefile%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<blockquote><p>Makefile是一种工程管理文件，其定义了一系列的规则来指定哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，在C/C++项目中较为常见。</p></blockquote><span id="more"></span><h3 id="一、Makefile介绍"><a href="#一、Makefile介绍" class="headerlink" title="一、Makefile介绍"></a>一、Makefile介绍</h3><p>make命令执行时，需要一个Makefile文件，以告诉make命令需要怎么样去编译和链接程序。</p><h4 id="1-1-规则"><a href="#1-1-规则" class="headerlink" title="1.1 规则"></a>1.1 规则</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile">target ... : prerequisites ...<br>    command<br>    ...<br>    ...<br></code></pre></td></tr></table></figure><ul><li><code>target</code>: 可以是一个<code>object file</code>(目标文件)、执行文件或标签。</li><li><code>prerequisites</code>:生成该<code>target</code>所依赖的文件和<code>/</code>或 <code>target</code></li><li><code>comm1and</code>:该<code>target</code>要执行的命令(任意的<code>shell</code>命令)</li></ul><p><strong>这表示一个文件的依赖关系，即<code>target</code>这一个或多个的目标文件依赖于<code>prerequisites</code>中的文件，其生成规则定义在<code>command</code>中</strong></p><blockquote><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">prerequisites中如果有一个以上的文件比<span class="hljs-keyword">target</span>文件要新的话，<span class="hljs-keyword">command</span>所定义的命令就会被执行。<br></code></pre></td></tr></table></figure></blockquote><h4 id="1-2-make工作"><a href="#1-2-make工作" class="headerlink" title="1.2 make工作"></a>1.2 make工作</h4><ul><li>make在当前目录寻找名字叫<code>makefile</code>或<code>Makefile</code>的文件。</li><li>如果找到，首先找第一个目标文件，并将其当作最终的目标文件。</li><li>如果第一个目标文件不存在，或者依赖文件的修改时间比该目标文件新，则会执行后面定义的命令来生成该目标文件。</li><li>如果所依赖的文件也不存在，那么会在当前文件找目标为依赖文件的依赖性，根据相应规则生成依赖文件。</li></ul><p>显然，体现一个层级寻找生成的过程。其中一环出现错误，make会不工作，并爆出相关异常。</p><h4 id="1-3-Makefile中使用变量"><a href="#1-3-Makefile中使用变量" class="headerlink" title="1.3 Makefile中使用变量"></a>1.3 Makefile中使用变量</h4><p>声明一个变量</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile">objects = main.o kbd.o command.o display.o \<br>     insert.o search.o files.o utils.o<br></code></pre></td></tr></table></figure><p><code>objects</code>为变量名，采用<code>$(objects)</code>进行引用</p><h4 id="1-4-Makefile自动推导"><a href="#1-4-Makefile自动推导" class="headerlink" title="1.4 Makefile自动推导"></a>1.4 Makefile自动推导</h4><p>make可以自动推导文件以及文件依赖关系后面的命令，故无需在每一个<code>.o</code>文件上都写上类似的命令。</p><p>只要make看到一个<code>.o</code>文件，它就会自动把<code>.c</code>文件加到依赖关系中，比如如果make找到一个<code>whatever.o</code>，那么<code>whatever.c</code>就会是<code>whatever.o</code>的依赖文件。并且<code>cc -c whatever.c</code>也会被推导出来。</p><p>在Makefile文件中使用<code>.PHONY</code>表示依赖是伪目标文件</p><h4 id="1-5-Makefile的主要内容"><a href="#1-5-Makefile的主要内容" class="headerlink" title="1.5 Makefile的主要内容"></a>1.5 Makefile的主要内容</h4><ul><li>显示规则: 要生成的文件、文件的依赖文件、生成命令。</li><li>隐晦规则。</li><li>变量的定义</li><li>文件指示。<ul><li>引用另外一个Makefile文件<ul><li>采用<code>include &lt;filename&gt;</code>进行引入，<code>filename</code>可以是当前操作系统Shell的文件模式，即可以包含路径和通配符。<code>include</code>前面可以有一些空字符，但是不能够从<code>Tab</code>键开始。</li></ul></li><li>根据某些情况制定Makefile的有效部分。</li><li>定义一个多行命令</li></ul></li><li>注释：注释采用<code>#</code></li></ul><p><strong>Makefile中的命令需要以Tab键开始</strong></p><h3 id="二、书写规则"><a href="#二、书写规则" class="headerlink" title="二、书写规则"></a>二、书写规则</h3><h4 id="2-1-在规则中使用通配符"><a href="#2-1-在规则中使用通配符" class="headerlink" title="2.1 在规则中使用通配符"></a>2.1 在规则中使用通配符</h4><p>支持<code>~</code>、<code>?</code>、<code>*</code>通配符。</p><ul><li><code>~</code>：一般表示当前用户的用户目录。</li><li><code>*</code>：一般表示匹配所有的意思。</li><li><code>?</code>：一般表示单个字符</li></ul><p><strong>想要在变量中展开通配符的写法</strong></p><p><code>objects := $(wildcard *.o)</code></p><h4 id="2-2-文件搜寻"><a href="#2-2-文件搜寻" class="headerlink" title="2.2 文件搜寻"></a>2.2 文件搜寻</h4><p>采用特殊变量<code>VPATH</code></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile">VPATH = src:../headers<br></code></pre></td></tr></table></figure><p>目录由冒号分隔。</p><p>也可以采用make中的<code>vpath</code>命令。</p><h4 id="2-3-伪目标"><a href="#2-3-伪目标" class="headerlink" title="2.3 伪目标"></a>2.3 伪目标</h4><p>“伪目标”不是一个文件，而是一个标签。<strong>不能够与文件名重名</strong></p><p>可以采用<code>.PHONY</code>进行显式地指明一个目标是“伪目标”。</p><h4 id="2-4-静态模式"><a href="#2-4-静态模式" class="headerlink" title="2.4 静态模式"></a>2.4 静态模式</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile">&lt;targets ...&gt; : &lt;target-pattern&gt; : &lt;prereq-patterns ...&gt;<br>    &lt;commands&gt;<br>    ...<br></code></pre></td></tr></table></figure><ul><li><code>targets</code>:定义了一系列的目标文件，即目标的集合</li><li><code>target-pattern</code>：指明了targets的模式，即目标集的模式。</li><li><code>prereq-patterns</code>:是目标的依赖模式，对<code>target-pattern</code>形成的模式再进行一次依赖目标的定义。</li></ul><p>即 若<code>&lt;target-pattern&gt;</code>定义成<code>%.o</code>,表示我们的<code>target</code>都是以<code>.o</code>结尾的。而如果<code>prereq-pattern</code>定义成<code>%.c</code>意思是对<code>target-pattern</code>所形成的目标集进行二次定义，其计算方式是取<code>target-pattern</code>模式中的<code>%</code>，并为其加上<code>.c</code>这个结尾，形成新的集合。</p><p><strong>该方式能够更方便的生成多目标文件</strong></p><h4 id="2-5-自动生成依赖性"><a href="#2-5-自动生成依赖性" class="headerlink" title="2.5 自动生成依赖性"></a>2.5 自动生成依赖性</h4><p>现有的C/C++编译器都支持一个”-M”的选项，能够<strong>自动找寻源文件包含的头文件，并生成一个依赖关系</strong>。</p><p>GNU组织建议通过把编译器为每一个源文件的自动生成的依赖关系放到一个文件中，为每一个<code>name.c</code>的文件都生成一个<code>name.d</code>的Makefile文件，<code>.d</code>文件中就存放对应<code>.c</code>文件的依赖关系。</p><h3 id="三、书写命令"><a href="#三、书写命令" class="headerlink" title="三、书写命令"></a>三、书写命令</h3><p>每条规则中的命令和操作系统Shell的命令行是一致的，make会一按顺序一条条的执行命令，每条命令的开头必须以<code>Tab</code>键开头，除非是跟在依赖规则后面的分号后。</p><h4 id="3-1-显示命令"><a href="#3-1-显示命令" class="headerlink" title="3.1 显示命令"></a>3.1 显示命令</h4><p><code>@</code>字符在命令行前，该命令不会被make显示出来，即会执行，不会输出相关命令。</p><h4 id="3-2-命令执行"><a href="#3-2-命令执行" class="headerlink" title="3.2 命令执行"></a>3.2 命令执行</h4><p>当依赖目标新于目标是时，make会一条一条执行气候的命令，若<strong>想要上一条命令的结果应用在下一条命令时，需采用分号分隔这两条命令</strong>。</p><p>要想忽略命令的出错，可以采用<code>-</code>(在Tab键之后)</p><h4 id="3-3-嵌套执行make"><a href="#3-3-嵌套执行make" class="headerlink" title="3.3 嵌套执行make"></a>3.3 嵌套执行make</h4><p>假设有一个子目录叫<code>subdir</code>，这个目录下有个<code>Makefile</code>文件，来指明了这个目录下文件的编译规则。总控的Makefile可以这样书写:</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">subsystem:</span><br>    cd subdir &amp;&amp; <span class="hljs-variable">$(MAKE)</span><br></code></pre></td></tr></table></figure><p>其等价于：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">subsystem:</span><br>    <span class="hljs-variable">$(MAKE)</span> -C subdir<br></code></pre></td></tr></table></figure><p><strong>传递变量到下级Makefile</strong></p><p><code>export &lt;variable ...&gt;;</code></p><p><strong>不想某些变量传递到下级</strong></p><p><code>unexport &lt;variable ...&gt;;</code></p><p><code>SHELL</code>、<code>MAKEFLAGS</code>这两个不管是否<code>export</code>总是需要传递到下层的Makefile中去的。</p><p><code>MAKEFLAGS</code>变量，其中包含了 <code>make</code>的参数信息。若<strong>执行总控Makefile时有make参数或是在上层Makefile中定义了这个变量，那么该变量将会是这些参数，并会传递到下层Makefile中</strong></p><h4 id="3-4-定义命令包"><a href="#3-4-定义命令包" class="headerlink" title="3.4 定义命令包"></a>3.4 定义命令包</h4><p>定义这种命令序列的语法以<code>define</code>开始，以<code>endef</code>结束。</p><p>注意:<strong>不要与Makefile中的变量重名</strong></p><h3 id="四、使用变量"><a href="#四、使用变量" class="headerlink" title="四、使用变量"></a>四、使用变量</h3><p>变量可以在“目标”、“依赖目标”、“命令”或是Makefile的其他部分中。</p><p>变量的命名字可以包含字符、数字，下划线（可以是数字开头），但不应该含有 <code>:</code> 、 <code>#</code> 、 <code>=</code> 或是空字符（空格、回车等）；</p><h4 id="4-1-变量相关注意点以及用法"><a href="#4-1-变量相关注意点以及用法" class="headerlink" title="4.1 变量相关注意点以及用法"></a>4.1 变量相关注意点以及用法</h4><ul><li><p>声明时需要赋初值。使用时需要在变量名前使用<code>$</code>，并推荐采用小括号<code>()</code>或<code>&#123;&#125;</code>把变量包括起来。</p></li><li><p>为了避免变量的递归调用，可以采用<code>:=</code>,该方式表示前面的变量不能够使用后面的变量。</p></li><li><p>如果想要定义一个变量其值为空格，可以采用如下方式：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile">nullstring :=<br>space :=<span class="hljs-variable">$(nullstring)</span> <span class="hljs-comment">#end of the line</span><br></code></pre></td></tr></table></figure></li><li><p><code>?=</code>操作符表示变量如果没有被定义，则定义，否则什么也不做。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile">FOO ?= bar <span class="hljs-comment"># 表示如果FOO没有被定义过，则定义其值为bar，否则什么也不做。</span><br><br></code></pre></td></tr></table></figure></li></ul><h4 id="4-2-变量的高级用法"><a href="#4-2-变量的高级用法" class="headerlink" title="4.2 变量的高级用法"></a>4.2 变量的高级用法</h4><ul><li><p>变量替换</p><ul><li>格式<code>$(var:a=b)</code>或<code>$&#123;var:a=b&#125;</code>，表示把变量”var”中所有以”a”字串结尾替换成”b”字串。</li></ul></li><li><p>把变量的值再当做变量。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile">x=y<br>y=z<br>a := $(<span class="hljs-variable">$(x)</span>) <span class="hljs-comment"># $(a)= z</span><br></code></pre></td></tr></table></figure></li><li><p>可以使用多个变量来组成一个变量的名字，然后取值。</p>  <figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment">#示例</span><br>first_second = Hello<br>a = first<br>b = second<br>all = $($a_$b)<br></code></pre></td></tr></table></figure></li></ul><h4 id="4-3-追加变量值"><a href="#4-3-追加变量值" class="headerlink" title="4.3 追加变量值"></a>4.3 追加变量值</h4><p>采用<code>+=</code>操作符相当于给变量追加值。如果变量没有被定义过，则会自动变成<code>=</code>（这个不用担心会发生递归）,如果之前有定义，则会继承于前次操作的赋值符。</p><h4 id="4-4-多行变量"><a href="#4-4-多行变量" class="headerlink" title="4.4 多行变量"></a>4.4 多行变量</h4><p>采用<code>define</code>和<code>endef</code>进行定义，<code>define</code>后面跟的是变量的名字，而重起一行定义变量的值。注意:<strong>命令需要以TAB键起头</strong></p><h4 id="4-5-环境变量"><a href="#4-5-环境变量" class="headerlink" title="4.5 环境变量"></a>4.5 环境变量</h4><p>如果Makefile中定义了与环境变量相同的变量，那么系统的环境变量的值会被覆盖。</p><h4 id="4-6-目标变量"><a href="#4-6-目标变量" class="headerlink" title="4.6 目标变量"></a>4.6 目标变量</h4><p>在Makefile中定义的变量都是“全局变量”，”自动化变量”如<code>$&lt;</code>属于规则型变量，这种变量的值依赖于规则的目标和依赖目标的定义。</p><p>也可以为某个目标设置局部变量，这种变量被称为“Target-specific Variable”，它可以和“全局变量”同名，因为它的作用范围只在这条规则以及连带规则中，所以其值也只在作用范围内有效。而不会影响规则链以外的全局变量的值。</p><p>语法:</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile">&lt;target ...&gt; : &lt;variable-assignment&gt;;<br><br>&lt;target ...&gt; : overide &lt;variable-assignment&gt;<br></code></pre></td></tr></table></figure><p><code>&lt;variable-assignment&gt;</code>可以是前面讲过的各种赋值表达式，如 <code>=</code> 、 <code>:=</code> 、 <code>+=</code> 或是 <code>?=</code> 。第二个语法是针对于make命令行带入的变量，或是系统环境变量。</p><h3 id="五、使用条件"><a href="#五、使用条件" class="headerlink" title="五、使用条件"></a>五、使用条件</h3><p><code>ifeq</code> 、 <code>else</code> 和 <code>endif</code> 。 </p><ul><li><code>ifeq</code> 的意思表示条件语句的开始，并指定一个条件表达式，表达式包含两个参数，以逗号分隔，表达式以圆括号括起。 </li><li><code>else</code> 表示条件表达式为假的情况。 </li><li><code>endif</code> 表示一个条件语句的结束，任何一个条件表达式都应该以 <code>endif</code> 结束。</li></ul><p>语法</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><br>&lt;conditional-directive&gt;<br>&lt;text-if-true&gt;<br><span class="hljs-keyword">endif</span><br>或<br>&lt;conditional-directive&gt;<br>&lt;text-if-true&gt;<br><span class="hljs-keyword">else</span><br>&lt;text-if-false&gt;<br><span class="hljs-keyword">endif</span><br><br><br></code></pre></td></tr></table></figure><p><strong>四个关键字</strong></p><ul><li><p><code>ifeq</code>: 比较参数 <code>arg1</code> 和 <code>arg2</code> 的值是否相同。当然，参数中我们还可以使用make的函数。</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs perl">ife<span class="hljs-string">q (&lt;arg1&gt;, &lt;arg2&gt;)</span><br>ifeq <span class="hljs-string">&#x27;&lt;arg1&gt;&#x27;</span> <span class="hljs-string">&#x27;&lt;arg2&gt;&#x27;</span><br>ifeq <span class="hljs-string">&quot;&lt;arg1&gt;&quot;</span> <span class="hljs-string">&quot;&lt;arg2&gt;&quot;</span><br>ifeq <span class="hljs-string">&quot;&lt;arg1&gt;&quot;</span> <span class="hljs-string">&#x27;&lt;arg2&gt;&#x27;</span><br>ifeq <span class="hljs-string">&#x27;&lt;arg1&gt;&#x27;</span> <span class="hljs-string">&quot;&lt;arg2&gt;&quot;</span><br></code></pre></td></tr></table></figure></li><li><p><code>ifneq</code>： 其比较参数 <code>arg1</code> 和 <code>arg2</code> 的值是否相同，如果不同，则为真。和 <code>ifeq</code> 类似。</p></li><li><p><code>ifdef</code>: 如果变量 <code>&lt;variable-name&gt;</code> 的值非空，那到表达式为真。否则，表达式为假。当然， <code>&lt;variable-name&gt;</code> 同样可以是一个函数的返回值。注意， <code>ifdef</code> 只是测试一个变量是否有值，其并不会把变量扩展到当前位置。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-keyword">ifdef</span> &lt;variable-name&gt;<br>bar =<br>foo = <span class="hljs-variable">$(bar)</span><br><span class="hljs-keyword">ifdef</span> foo<br>    frobozz = yes<br><span class="hljs-keyword">else</span><br>    frobozz = no<br><span class="hljs-keyword">endif</span><br><br><span class="hljs-comment"># $(frobozz) 为yes</span><br>foo =<br><span class="hljs-keyword">ifdef</span> foo<br>    frobozz = yes<br><span class="hljs-keyword">else</span><br>    frobozz = no<br><span class="hljs-keyword">endif</span><br><span class="hljs-comment"># $(frobozz) 为no</span><br><br></code></pre></td></tr></table></figure></li><li><p><code>ifndef</code>:和 <code>ifdef</code> 是相反的意思。</p></li></ul><p>注意:<strong>在 <code>&lt;conditional-directive&gt;</code> 这一行上，多余的空格是被允许的，但是不能以 <code>Tab</code> 键作为开始（不然就被认为是命令）。而注释符 <code>#</code> 同样也是安全的。 <code>else</code> 和 <code>endif</code> 也一样，只要不是以 <code>Tab</code> 键开始就行了,最好不要把自动化变量（如 <code>$@</code> 等）放入条件表达式中，因为自动化变量是在运行时才有的。。</strong></p><h3 id="六、使用函数"><a href="#六、使用函数" class="headerlink" title="六、使用函数"></a>六、使用函数</h3><p><strong>函数调用语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash">(&lt;<span class="hljs-keyword">function</span>&gt; &lt;arguments&gt;) or <span class="hljs-variable">$&#123;&lt;function&gt; &lt;arguments&gt;&#125;</span></span><br></code></pre></td></tr></table></figure><p><code>&lt;function&gt;</code> 就是函数名，make支持的函数不多。 <code>&lt;arguments&gt;</code> 为函数的参数，参数间以逗号 <code>,</code> 分隔，而函数名和参数之间以“空格”分隔.函数调用以 <code>$</code> 开头，以圆括号或花括号把函数名和参数括起.函数和变量的括号最好一样，如使用 <code>$(subst a,b,$(x))</code> 这样的形式，而不是 <code>$(subst a,b, $&#123;x&#125;)</code> 的形式。因为统一会更清楚，也会减少一些不必要的麻烦。</p><h3 id="七、make的运行"><a href="#七、make的运行" class="headerlink" title="七、make的运行"></a>七、make的运行</h3><p>通常来说，make的最终目标是Makefile中的第一个目标，而其他目标一般是由这个目标连带出来的。<strong>要想指定目标，需在make命令后直接跟目标的名字就可以完成</strong></p><p><code>MAKECMDGOALS</code>存放你所指定的终极目标的列表。若在命令行上，没有指定目标，其值则为空值。</p><h3 id="八、隐含规则"><a href="#八、隐含规则" class="headerlink" title="八、隐含规则"></a>八、隐含规则</h3><h4 id="8-1-模式规则"><a href="#8-1-模式规则" class="headerlink" title="8.1 模式规则"></a>8.1 模式规则</h4><p>目标中的<code>%</code>定义表示对文件名的匹配,<code>%</code>表示长度任意的非空字符串。</p><p><strong>如果<code>%</code>定义在目标中，那么目标中的<code>%</code>的值决定了依赖目标中的<code>%</code>的值</strong></p><h4 id="8-2-自动变量"><a href="#8-2-自动变量" class="headerlink" title="8.2 自动变量"></a>8.2 自动变量</h4><ul><li><code>$@</code> : 表示规则中的目标文件集。在模式规则中，如果有多个目标，那么， <code>$@</code> 就是匹配于目标中模式定义的集合。</li><li><code>$%</code> : 仅当目标是函数库文件中，表示规则中的目标成员名。例如，如果一个目标是 <code>foo.a(bar.o)</code> ，那么， <code>$%</code> 就是 <code>bar.o</code> ， <code>$@</code> 就是 <code>foo.a</code> 。如果目标不是函数库文件（Unix下是 <code>.a</code> ，Windows下是 <code>.lib</code> ），那么，其值为空。</li><li><code>$&lt;</code> : 依赖目标中的第一个目标名字。如果依赖目标是以模式（即 <code>%</code> ）定义的，那么 <code>$&lt;</code> 将是符合模式的一系列的文件集。注意，其是一个一个取出来的。</li><li><code>$?</code> : 所有比目标新的依赖目标的集合。以空格分隔。</li><li><code>$^</code> : 所有的依赖目标的集合。以空格分隔。如果在依赖目标中有多个重复的，那么这个变量会去除重复的依赖目标，只保留一份。</li><li><code>$+</code> : 这个变量很像 <code>$^</code> ，也是所有依赖目标的集合。只是它不去除重复的依赖目标。</li><li><code>$*</code> : 这个变量表示目标模式中 <code>%</code> 及其之前的部分。如果目标是 <code>dir/a.foo.b</code> ，并且目标的模式是 <code>a.%.b</code> ，那么， <code>$*</code> 的值就是 <code>dir/a.foo</code> 。这个变量对于构造有关联的文件名是比较有较。如果目标中没有模式的定义，那么 <code>$*</code> 也就不能被推导出，但是，如果目标文件的后缀是make所识别的，那么 <code>$*</code> 就是除了后缀的那一部分。例如：如果目标是 <code>foo.c</code> ，因为 <code>.c</code> 是make所能识别的后缀名，所以， <code>$*</code> 的值就是 <code>foo</code> 。这个特性是GNU make的，很有可能不兼容于其它版本的make，所以，你应该尽量避免使用 <code>$*</code> ，除非是在隐含规则或是静态模式中。如果目标中的后缀是make所不能识别的，那么 <code>$*</code> 就是空值。</li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Makefile</tag>
      
      <tag>工程项目管理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在C中指针的高级技巧</title>
    <link href="/2021/12/10/%E5%9C%A8C%E4%B8%AD%E6%8C%87%E9%92%88%E7%9A%84%E9%AB%98%E7%BA%A7%E6%8A%80%E5%B7%A7/"/>
    <url>/2021/12/10/%E5%9C%A8C%E4%B8%AD%E6%8C%87%E9%92%88%E7%9A%84%E9%AB%98%E7%BA%A7%E6%8A%80%E5%B7%A7/</url>
    
    <content type="html"><![CDATA[<blockquote><p>对于初学者来说，指针是比较头疼的东西，但是，如果你想深入了解底层的一些东西，指针你又是避不开的。既然逃避不了，干嘛不加入呢？一起继续探索指针中更高级更好玩的技巧吧！😄<span id="more"></span></p></blockquote><h3 id="1-回顾"><a href="#1-回顾" class="headerlink" title="1 回顾"></a>1 回顾</h3><p><strong>指针</strong>也指内存地址，<strong>指针变量</strong>是用来存放内存地址的变量，在32位的操作系统中，它的大小为4个字节，在64位的操作系统中则是8个字节，依次类推…</p><p><strong>c语言中常见的指针变量定义</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**********************part one**********************/</span><br><span class="hljs-comment">//声明一个存储整型变量地址的指针</span><br><span class="hljs-keyword">int</span> *p; <br><br><span class="hljs-comment">//使用方式</span><br><span class="hljs-keyword">int</span> c;<br>p = &amp;c;<br><br><span class="hljs-comment">/**********************part two**********************/</span><br><span class="hljs-comment">//声明一个存储 指向整型变量的指针 的地址的指针 即指向指针的指针</span><br><span class="hljs-keyword">int</span> **pp; <br><span class="hljs-comment">//使用方式</span><br><span class="hljs-keyword">int</span> *p_1;<br>pp = &amp;p_1;<br><br><br><span class="hljs-comment">/**********************part three**********************/</span><br><span class="hljs-keyword">int</span> *p[]; <span class="hljs-comment">//声明一个数组，该数组存储的内容为整型变量地址即整型指针</span><br><br><span class="hljs-comment">//使用方式</span><br><span class="hljs-keyword">int</span> d;<br>p[<span class="hljs-number">0</span>] = &amp;d; <br><br> <span class="hljs-comment">/**********************part four**********************/</span><br><span class="hljs-keyword">int</span> (*p)[<span class="hljs-number">4</span>]; <span class="hljs-comment">//声明一个指针变量，指向的是数组 </span><br><br><span class="hljs-comment">//使用方式</span><br><span class="hljs-keyword">int</span> a[<span class="hljs-number">4</span>];<br>p = &amp;a;<br><br></code></pre></td></tr></table></figure><h3 id="2-声明推断"><a href="#2-声明推断" class="headerlink" title="2 声明推断"></a>2 声明推断</h3><p>从回顾中，我们简单回顾了一些常见的指针用法，下面继续看看一些有意思的声明以及理解这个声明到底是什么意思。</p><p>注意: <strong>用于声明变量的表达式和普通的表达式在求值时所使用的规则相同。</strong></p><p><strong>示例一</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//一个整型变量</span><br><span class="hljs-keyword">int</span> i;<br><span class="hljs-comment">//一个指向整型的指针</span><br><span class="hljs-keyword">int</span> *i_p;<br></code></pre></td></tr></table></figure><p>针对这个<code>*i_P</code>，可以理解成<strong>被声明为了一个整数</strong>,但它用<code>*</code>表示了这个表达式，所以可以理解成<strong>这是一个指针变量，它指向的地址存储的是整数</strong></p><p><strong>示例二</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//声明一个函数原型</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>;<br><span class="hljs-comment">//声明一个返回整型指针的函数原型</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> *<span class="hljs-title">f</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure><p>对于表达式<code>*f()</code>，优先级最高的是<code>()</code>,所以声明时最先与<code>f</code>结合的是<code>()</code>，所以这是一个函数，既然知道了它是一个函数，那么剩下的部分就应该的是它的返回值类型了，所以可以理解成<strong>这是一个回整型指针的函数原型</strong></p><p><strong>示例三</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//1.</span><br><span class="hljs-keyword">int</span> (*f)();<br><span class="hljs-comment">//2.</span><br><span class="hljs-keyword">int</span> *(*f)();<br></code></pre></td></tr></table></figure><p>如果能够理解示例一与二的推断方式，那么针对这个示例应该是很容易理解。</p><p>表达式<code>(*f)()</code>中由于括号优先级，可以看到<code>f</code>先与<code>*</code>结合，所以<code>f</code>是一个指针，接下来的是与第二个括号结合，说明这个指针指向的是一个函数，这个函数的返回值为整型。所以整体理解就是<strong>这是一个指向/返回整型的函数的/首地址的指针</strong>，即<strong>函数指针</strong></p><p>表达式<code>*(*f)()</code>这个与<code>(*f)()</code>声明多了左边的<code>*</code>,也就是相当于函数的返回类型是整型指针，故可以理解为<strong>这是一个指向/返回整型指针的函数的/首地址的指针</strong></p><p><strong>示例四</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//以下先省略数组长度</span><br><span class="hljs-comment">//1.</span><br><span class="hljs-keyword">int</span> * f[];<br><br><span class="hljs-comment">//错误示例</span><br><span class="hljs-comment">//2.</span><br><span class="hljs-keyword">int</span> f[]();<br><span class="hljs-comment">//3.</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">f</span><span class="hljs-params">()</span>[]</span>;<br></code></pre></td></tr></table></figure><p>下面序号1、2、3分别代码中的三个声明：</p><ol><li>表达式<code>*f[]</code>中优先级最高的是<code>[]</code>，所以这个是一个数组，数组元素存储的是整型指针。</li><li>表达式<code>f[]()</code>中的<code>f</code>先与<code>[]</code>结合，所以它是一个数组，然后它的是元素类型是函数，这是错的!，对于一个函数来说，不同的函数长度是不一样的，然而对于数组来说，要求是一样的，所以这个声明无法成立。</li><li><code>f()[]</code>中的<code>f</code>先与<code>()</code>结合，所以它是一个函数，那么它的返回值就是数组，然而函数中不能够返回数组，所以这个声明也是错的。</li></ol><p><strong>示例五</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">int</span> *(*f[])();<br></code></pre></td></tr></table></figure><p>这个声明表达式阅读起来确实有点困难！但是依然可以用上面的拆解方式进行解读。<code>*(*f[])()</code>是由<code>*</code>,<code>(*f[])</code>,<code>()</code>组成，显然<code>(*f[])</code>优先级更高，所以根据这个括号的内容知道这个<code>f</code>一定是一个数组，然后它应该存储的是xx类型的指针，要看是什么类型的指针，还得看外面，噢是<code>()</code>啊，那就是函数，所以它存储的内容是函数的指针。那么这个函数的返回值是什么呢?噢，左边是一个<code>*</code>，所以它是返回了一个整型的指针。</p><blockquote><p>分析这个表达式实在是头大的话，建议反复阅读这几个示例！</p></blockquote><p>注意，如果函数有参数的话，声明涉及到函数原型时最好注明参数类型，如:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">int</span> (*f)(<span class="hljs-keyword">int</span>,<span class="hljs-keyword">float</span>);<br><span class="hljs-keyword">int</span> *(*g[])(<span class="hljs-keyword">int</span>,<span class="hljs-keyword">float</span>);<br></code></pre></td></tr></table></figure><h3 id="3-函数指针"><a href="#3-函数指针" class="headerlink" title="3 函数指针"></a>3 函数指针</h3><p>函数指针上面举例子的时候，已经被举例过了，它就是指向函数的指针变量。在c中，函数也会有存储空间的，也有对应的入口地址，函数名一般就是指向这个入口的地址。</p><p><strong>函数指针的初始化与使用</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span></span>;<br><span class="hljs-keyword">int</span> (*pf)(<span class="hljs-keyword">int</span>) = &amp;f; <span class="hljs-comment">//这个&amp;是可选的，因为函数名被使用时总是由编译器把它转换为函数指针。</span><br><br><span class="hljs-keyword">int</span> ans;<br>ans = f(<span class="hljs-number">25</span>); <span class="hljs-comment">//函数名调用</span><br>ans = (*pf)(<span class="hljs-number">25</span>); <span class="hljs-comment">//间接访问得到一个函数名然后调用</span><br>ans = pf(<span class="hljs-number">25</span>); <span class="hljs-comment">//与第一个一样，间接访问非必须</span><br></code></pre></td></tr></table></figure><h4 id="3-1-函数指针的应用场景一-回调函数"><a href="#3-1-函数指针的应用场景一-回调函数" class="headerlink" title="3.1 函数指针的应用场景一: 回调函数"></a>3.1 函数指针的应用场景一: 回调函数</h4><p>说起回调函数，其实在很多地方能够见到这个东西，比如点击按钮时，执行什么；发起一个<code>http</code>异步请求，处理响应结果时等等。</p><p>回调函数往往时这样: 把一个函数作为参数传递给其他函数，后者将会”回调“该函数。</p><p><strong>示例代码</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;error.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DataType char</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>&#123;</span><br>    DataType value;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> * <span class="hljs-title">next</span>;</span><br>&#125;;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>* <span class="hljs-title">LinkNode</span>;</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>* <span class="hljs-title">LinkList</span>;</span><br><br><br><br><span class="hljs-function">LinkList <span class="hljs-title">creat_linklist</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add_element</span><span class="hljs-params">(LinkList <span class="hljs-built_in">list</span>,DataType value)</span></span>;<br><br><span class="hljs-comment">/************************************key point*****************************************************/</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">search_value</span><span class="hljs-params">(LinkList <span class="hljs-built_in">list</span>,<span class="hljs-keyword">void</span> <span class="hljs-keyword">const</span>* value,<span class="hljs-keyword">int</span> (*compare)(<span class="hljs-keyword">void</span> <span class="hljs-keyword">const</span> * ,<span class="hljs-keyword">void</span> <span class="hljs-keyword">const</span> *))</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">compare_self_impl</span><span class="hljs-params">(<span class="hljs-keyword">void</span> <span class="hljs-keyword">const</span> * op1,<span class="hljs-keyword">void</span> <span class="hljs-keyword">const</span> * op2)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">compare_self_impl_char</span><span class="hljs-params">(<span class="hljs-keyword">void</span> <span class="hljs-keyword">const</span> * op1,<span class="hljs-keyword">void</span> <span class="hljs-keyword">const</span> * op2)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>    <span class="hljs-comment">//创建一个空链表</span><br>    LinkList <span class="hljs-built_in">list</span>=creat_linklist();<br>    add_element(<span class="hljs-built_in">list</span>,<span class="hljs-string">&#x27;a&#x27;</span>);<br>    add_element(<span class="hljs-built_in">list</span>,<span class="hljs-string">&#x27;b&#x27;</span>);<br>    add_element(<span class="hljs-built_in">list</span>,<span class="hljs-string">&#x27;d&#x27;</span>);<br>    <span class="hljs-keyword">char</span> c=<span class="hljs-string">&#x27;a&#x27;</span>;<br>    <span class="hljs-keyword">int</span> result = search_value(<span class="hljs-built_in">list</span>,&amp;c,compare_self_impl_char);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, result);<br><br><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br><span class="hljs-function">LinkList <span class="hljs-title">creat_linklist</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    LinkList <span class="hljs-built_in">list</span> = (LinkList) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(struct Node));<br>    <span class="hljs-built_in">list</span>-&gt;next=<span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">list</span>;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add_element</span><span class="hljs-params">(LinkList <span class="hljs-built_in">list</span>,DataType value)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">list</span>)<br>        <span class="hljs-built_in">exit</span>(ERROR_INVALID_PARAMETER);<br>    LinkNode new_node = (LinkNode) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(struct Node));<br>    new_node-&gt;next=<span class="hljs-built_in">list</span>-&gt;next;<br>    new_node-&gt;value=value;<br>    <span class="hljs-built_in">list</span>-&gt;next=new_node;<br>&#125;<br><br><br><span class="hljs-comment">/************************************key point*****************************************************/</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">search_value</span><span class="hljs-params">(LinkList <span class="hljs-built_in">list</span>,<span class="hljs-keyword">void</span> <span class="hljs-keyword">const</span> * value,<span class="hljs-keyword">int</span> (*compare)(<span class="hljs-keyword">void</span> <span class="hljs-keyword">const</span> * ,<span class="hljs-keyword">void</span> <span class="hljs-keyword">const</span> *))</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> result = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">list</span>)<br>        <span class="hljs-built_in">exit</span>(ERROR_INVALID_PARAMETER);<br>    LinkNode p = <span class="hljs-built_in">list</span>-&gt;next;<br>    <span class="hljs-keyword">while</span> (p)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(compare(&amp;p-&gt;value,value) == <span class="hljs-number">1</span>)<br>        &#123;<br>            result = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        p=p-&gt;next;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><br><span class="hljs-comment">//实现自定义的比较函数 数字</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">compare_self_impl</span><span class="hljs-params">(<span class="hljs-keyword">void</span> <span class="hljs-keyword">const</span> * op1,<span class="hljs-keyword">void</span> <span class="hljs-keyword">const</span> * op2)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> *((<span class="hljs-keyword">int</span> *)op1) == *((<span class="hljs-keyword">int</span> *)op2) ? <span class="hljs-number">1</span>:<span class="hljs-number">0</span>;<br>&#125;<br><br><br><br><span class="hljs-comment">//实现自定义的比较函数 字符</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">compare_self_impl_char</span><span class="hljs-params">(<span class="hljs-keyword">void</span> <span class="hljs-keyword">const</span> * op1,<span class="hljs-keyword">void</span> <span class="hljs-keyword">const</span> * op2)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> *((<span class="hljs-keyword">char</span> *)op1) == *((<span class="hljs-keyword">char</span> *)op2) ? <span class="hljs-number">1</span>:<span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><code>search_value</code>函数用于查找某个值是否在链表中，它的内部必然涉及两个元素进行比较。如果我们的链表只针对某个特定的元素类型，那么它的实现就比较简单，直接内部进行取值比较就行了。但是如果想要更为通用，那么这个比较就不能在函数内部实现了（当然，你直接实现也可以，但是你得在内部进行判别类型）。这时候函数指针的用处就体现出来了，只需声明一个函数指针参数,其他元素类型只需重写这个比较函数，并提供函数地址，由<code>search_value</code>函数在内部调用即可。</p><p><code>search_value</code>函数的原型如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">search_value</span><span class="hljs-params">(LinkList <span class="hljs-built_in">list</span>,<span class="hljs-keyword">void</span> <span class="hljs-keyword">const</span> * value,<span class="hljs-keyword">int</span> (*compare)(<span class="hljs-keyword">void</span> <span class="hljs-keyword">const</span> * ,<span class="hljs-keyword">void</span> <span class="hljs-keyword">const</span> *))</span></span>;<br></code></pre></td></tr></table></figure><p>不知道你是否注意到其中的<code>int (*compare)(void const * ,void const *)</code>参数类型？由于声明这个函数原型的时候，是不知道具体参与比较的元素的类型的，所以为了匹配所有元素，故将类型定为<code>void *</code>。到时候声明一个符合该函数指针要求的函数时，则需在内部进行强制类型转换即可，这时肯定能知道所需要比较的参数类型了。</p><h4 id="3-2-函数指针的应用场景二：转移表"><a href="#3-2-函数指针的应用场景二：转移表" class="headerlink" title="3.2 函数指针的应用场景二：转移表"></a>3.2 函数指针的应用场景二：转移表</h4><p>假设，我们想要实现一个简单的<strong>加减乘除</strong>计算器，常见的实现方式:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">int</span> select_no,op1,op2,result;<br><span class="hljs-keyword">switch</span> (select_no) &#123;<br>    <span class="hljs-keyword">case</span> ADD:<br>    &#123;<br>        result= op1 + op2; <br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">case</span> SUB:<br>    &#123;<br>        result= op1 - op2;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">case</span> MUL:<br>    &#123;<br>        result= op1 * op2;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">case</span> DIV:<br>    &#123;<br>        result= op1 / op2; <span class="hljs-comment">//这里实现有点小瑕疵，但也很常见的</span><br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果我们想再增加更多的功能模块的话，这个<code>switch</code>语句将会更长。如果想要达到良好的程序设计，建议把具体操作与选择操作分开，即<strong>加减乘除</strong>操作的实现与选择分开，所以推荐使用函数实现，以便于后期扩展。</p><p>对于<code>switch</code>，需要知道的是: 表示操作符的分支必须是整数。所以我们可以想到，如果是从0开始的连续的整数，可以用数组来映射的，这就是转移表。所谓数组，就是存储函数指针的数组。</p><p><strong>示例代码</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">self_add</span><span class="hljs-params">(<span class="hljs-keyword">double</span> a,<span class="hljs-keyword">double</span> b)</span></span>&#123; <span class="hljs-keyword">return</span> a+b;&#125;<br><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">self_sub</span><span class="hljs-params">(<span class="hljs-keyword">double</span> a,<span class="hljs-keyword">double</span> b )</span></span>&#123;<span class="hljs-keyword">return</span> a-b;&#125;<br><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">self_mul</span><span class="hljs-params">(<span class="hljs-keyword">double</span> a,<span class="hljs-keyword">double</span> b )</span></span>&#123;<span class="hljs-keyword">return</span> a*b;&#125;<br><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">self_div</span><span class="hljs-params">(<span class="hljs-keyword">double</span> a,<span class="hljs-keyword">double</span> b )</span></span>&#123;<span class="hljs-keyword">return</span> a/b;&#125;<span class="hljs-comment">//这里实现有点小瑕疵</span><br><br><span class="hljs-comment">//定义一个函数指针数组，然后初始化</span><br><span class="hljs-keyword">double</span> (*oper_func[])(<span class="hljs-keyword">double</span> ,<span class="hljs-keyword">double</span> )=&#123;<br>        &amp;self_add, &amp;self_sub, &amp;self_mul, &amp;self_div<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">OP</span>&#123;</span>ADD=<span class="hljs-number">0</span>,SUB,MUL,DIV&#125;; <span class="hljs-comment">//定义 枚举</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <br>    <span class="hljs-keyword">double</span> a=oper_func[ADD](<span class="hljs-number">3</span>,<span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lf&quot;</span>,a);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>这里需要主要注意的是：</p><p><strong>既然用到了数组，就有可能发生越界行为，就可能会造成不可预料的结果，所以建议在使用需要保证在合理的范围内。</strong></p>]]></content>
    
    
    <categories>
      
      <category>C/C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C/C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解决Linux下交叉编译U-Boot源码时报&#39;multiple definition of `yylloc&#39;&#39;的错误</title>
    <link href="/2021/12/01/%E8%A7%A3%E5%86%B3Linux%E4%B8%8B%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91U-Boot%E6%BA%90%E7%A0%81%E6%97%B6%E6%8A%A5&#39;multiple%20definition%20of%20%60yylloc&#39;&#39;%E7%9A%84%E9%94%99%E8%AF%AF/"/>
    <url>/2021/12/01/%E8%A7%A3%E5%86%B3Linux%E4%B8%8B%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91U-Boot%E6%BA%90%E7%A0%81%E6%97%B6%E6%8A%A5&#39;multiple%20definition%20of%20%60yylloc&#39;&#39;%E7%9A%84%E9%94%99%E8%AF%AF/</url>
    
    <content type="html"><![CDATA[<blockquote><p>解决Linux下交叉编译U-Boot源码时报’multiple definition of `yylloc’’的错误。。。<span id="more"></span></p></blockquote><h3 id="一、编译环境"><a href="#一、编译环境" class="headerlink" title="一、编译环境"></a>一、编译环境</h3><div class="table-container"><table><thead><tr><th>环境</th><th>值</th></tr></thead><tbody><tr><td>操作系统</td><td>Fedora release 35 (Thirty Five)</td></tr><tr><td>交叉编译环境</td><td>gcc-linaro-6.1.1-2016.08-x86_64_aarch64-linux-gnu</td></tr><tr><td>Linux 内核版本</td><td>5.14.16</td></tr><tr><td>U-Boot版本</td><td>1.7.4（板子厂商特供版）</td></tr></tbody></table></div><h3 id="二、问题描述"><a href="#二、问题描述" class="headerlink" title="二、问题描述"></a>二、问题描述</h3><p>我们可以从报错信息看到，<code>dtc-parser.tab.o</code>和<code>scripts/dtc/dtc-lexer.lex.o</code>这两个中间文件中对<code>yylloc</code>多重定义了，导致在链接时，产生了报错。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//问题复现 操作指令</span><br>make ft2004_defconfig<br>make ARCH=arm CROSS_COMPILE=/usr/local/arm/<span class="hljs-number">6.1</span>/gcc-linaro<span class="hljs-number">-6.1</span><span class="hljs-number">.1</span><span class="hljs-number">-2016.08</span>-x86_64_aarch64-linux-gnu/bin/aarch64-linux-gnu-<br><br><br><span class="hljs-comment">//终端报错信息</span><br>  <span class="hljs-comment">//...</span><br>  LEX     scripts/dtc/dtc-lexer.lex.c<br>  YACC    scripts/dtc/dtc-parser.tab.h<br>  HOSTCC  scripts/dtc/dtc-lexer.lex.o<br>  YACC    scripts/dtc/dtc-parser.tab.c<br>  HOSTCC  scripts/dtc/dtc-parser.tab.o<br>  HOSTLD  scripts/dtc/dtc<br>/usr/bin/ld: scripts/dtc/dtc-parser.tab.o:(.bss+<span class="hljs-number">0x10</span>): multiple definition of `yylloc<span class="hljs-number">&#x27;</span>; scripts/dtc/dtc-lexer.lex.o:(.bss+<span class="hljs-number">0x0</span>): first defined here<br>collect2: error: ld returned <span class="hljs-number">1</span> <span class="hljs-built_in">exit</span> status<br>make[<span class="hljs-number">2</span>]: *** [scripts/Makefile.host:<span class="hljs-number">106</span>: scripts/dtc/dtc] Error <span class="hljs-number">1</span><br>make[<span class="hljs-number">1</span>]: *** [scripts/Makefile.build:<span class="hljs-number">432</span>: scripts/dtc] Error <span class="hljs-number">2</span><br>make: *** [Makefile:<span class="hljs-number">528</span>: scripts] Error <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>我百度了一下，有文章说可以通过修改<code>scripts/dtc/dtc-parser.tab.h</code>，将里面的<code>yylloc</code>定义去掉就好了<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="荔枝派编译uboot时出现错误multiple definition of `yylloc‘_zhvngchvng的博客">[1]</span></a></sup>，但是我发现我找不到这个文件。其实是因为我先执行了<code>make distclean</code>，清除了构建信息，这个文件就没有了，所以说这个改法不是永久的，就算是临时的，我发现我改了也没有作用😅。</p><p>也有文章说，是因为版本使用了<code>gcc-10</code>，对其进行降版本就行了<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="multiple definition of `yylloc’ - 永明">[2]</span></a></sup>，但是我交叉编译版本本来就是低于10的，所以说也是解决不了😫。</p><h3 id="三、🎉解决方案"><a href="#三、🎉解决方案" class="headerlink" title="三、🎉解决方案"></a>三、🎉解决方案</h3><h4 id="3-1-🎈方法一"><a href="#3-1-🎈方法一" class="headerlink" title="3.1 🎈方法一"></a>3.1 🎈方法一</h4><p>在问题描述那里，我已经指出，这是多重定义的原因。多重定义的出现是因为 <code>gcc</code>中的<code>-fcommon</code>将它们合并为一个了<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="Remove redundant YYLOC global declaration (018921ee) · Commits · U-Boot / U-Boot · GitLab (denx.de)">[3]</span></a></sup><sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><span class="hint--top hint--rounded" aria-label="scripts/dtc: Remove redundant YYLOC global declaration · torvalds/linux@e33a814 (github.com)">[4]</span></a></sup><sup id="fnref:5" class="footnote-ref"><a href="#fn:5" rel="footnote"><span class="hint--top hint--rounded" aria-label="Multiple definition of yylloc in u-boot and linux-kernel - githubmemory">[5]</span></a></sup>，尽管添加了<code>extern</code>还是会导致多重定义，故这就说明这个定义完全就是多余的，可以直接去掉也不影响程序的运行。</p><p>所以，你可以选择:</p><ol><li>下载最新的U-Boot版本，最新的已经删掉了。</li><li>前往<code>scripts/dtc/dtc-lexer.l</code>文件，找到<code>YYLTYPE yylloc;</code>并注释掉即可。</li></ol><blockquote><p>至于<code>-fcommon</code>是什么东西?，可以参考<a href="https://www.keil.com/support/man/docs/armclang_ref/armclang_ref_chr1422532346348.htm">-fcommon, -fno-common</a></p></blockquote><h4 id="3-2-🎈方法二"><a href="#3-2-🎈方法二" class="headerlink" title="3.2 🎈方法二"></a>3.2 🎈方法二</h4><p>换个系统试试，感觉交叉编译器在不同系统的编译行为有点奇怪😓目前还没找到原因….我是<code>Fedora</code>切换到了<code>Ubuntu</code>，构建成功了，人麻了。</p><h4 id="3-3-🎈方法三"><a href="#3-3-🎈方法三" class="headerlink" title="3.3 🎈方法三"></a>3.3 🎈方法三</h4><p>文章是通过在顶层文件<code>Makefile</code>中添加<code>HOSTCFLAGS  += -fcommon</code><sup id="fnref:6" class="footnote-ref"><a href="#fn:6" rel="footnote"><span class="hint--top hint--rounded" aria-label="编译itop4412 uboot失败，提示multiple definition of `yylloc‘； scripts/dtc/dtc-lexer.lex.o:(.bss+0x0): first_ZLK1214的专栏-CSDN博客">[6]</span></a></sup>，亲测有效，具体细节可以参考文章6。</p><h3 id="四、参考"><a href="#四、参考" class="headerlink" title="四、参考"></a>四、参考</h3><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://blog.csdn.net/zhvngchvng/article/details/108011175">荔枝派编译uboot时出现错误multiple definition of `yylloc‘_zhvngchvng的博客</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://www.cnblogs.com/mym1994/p/15424734.html">multiple definition of `yylloc’ - 永明</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a href="https://source.denx.de/u-boot/u-boot/-/commit/018921ee79d3f30893614b3b2b63b588d8544f73">Remove redundant YYLOC global declaration (018921ee) · Commits · U-Boot / U-Boot · GitLab (denx.de)</a><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:4" class="footnote-text"><span><a href="https://github.com/torvalds/linux/commit/e33a814e772cdc36436c8c188d8c42d019fda639">scripts/dtc: Remove redundant YYLOC global declaration · torvalds/linux@e33a814 (github.com)</a><a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:5" class="footnote-text"><span><a href="https://githubmemory.com/repo/OP-TEE/build/issues/420">Multiple definition of yylloc in u-boot and linux-kernel - githubmemory</a><a href="#fnref:5" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:6" class="footnote-text"><span><a href="https://blog.csdn.net/ZLK1214/article/details/113729027?spm=1001.2101.3001.6650.4&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-4.no_search_link&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-4.no_search_link">编译itop4412 uboot失败，提示multiple definition of `yylloc‘； scripts/dtc/dtc-lexer.lex.o:(.bss+0x0): first_ZLK1214的专栏-CSDN博客</a><a href="#fnref:6" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Bug</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C/C++</tag>
      
      <tag>Linux</tag>
      
      <tag>U-Boot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>教你计算算法的时间复杂度</title>
    <link href="/2021/11/28/%E6%95%99%E4%BD%A0%E8%AE%A1%E7%AE%97%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
    <url>/2021/11/28/%E6%95%99%E4%BD%A0%E8%AE%A1%E7%AE%97%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</url>
    
    <content type="html"><![CDATA[<blockquote><p>在计算机科学中，算法的时间复杂度（Time complexity）是一个函数，它定性描述该算法的运行时间。这是一个代表算法输入值的字符串的长度的函数。时间复杂度常用大O符号表述，不包括这个函数的低阶项和首项系数。<span id="more"></span> 使用这种方式时，时间复杂度可被称为是渐近的，亦即考察输入值大小趋近无穷时的情况。例如，如果一个算法对于任何大小为 n （必须比<code>n0</code>大）的输入，它至多需要<code>5n3 + 3n</code>的时间运行完毕，那么它的渐近时间复杂度是<code>O(n3)</code>。源自:<a href="https://zh.wikipedia.org/wiki/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6">wikipedia</a></p></blockquote><p>为了计算时间复杂度，我们通常会估计算法的操作单元数量，每个单元运行的时间都是相同的。因此，总运行时间和算法的操作单元数量最多相差一个常量系数。<br><strong>Step：</strong></p><ol><li>用常数1替代语句频度中所有的加法项；</li><li>在1 的结果中，只保留数的最高项；</li><li>最高阶项若系数不为1，则去除系数（或是改为1）。</li></ol><p>如果你没看懂，那继续往下看，笔者以例子与你详细介绍。<br><strong>例子1</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> sum=<span class="hljs-number">0</span>,i = <span class="hljs-number">0</span>;i &lt; N;i++)  <span class="hljs-comment">//1、</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;j &lt;N;j++)     <span class="hljs-comment">//2、</span><br>        sum=sum+i*j;           <span class="hljs-comment">//3、</span><br></code></pre></td></tr></table></figure><p>我们以一个语句记为1次，来：</p><ol><li><p>1行这里定义两个变量共一次，而中间循环，理论是判断是<code>N</code>次,但是实际上应该是<code>N+1</code>，最后等于<code>N</code>时还有判断<code>1</code>次  即<code>0~N</code>，故为<code>N+1</code>，循环变量的递增一共是<code>N</code>次，其语句频度为:</p><script type="math/tex; mode=display">O_1=1+(N+1)+N \tag{1.1}</script></li><li><p>2行这里第一个循环进入第二个循环，一共是<code>N</code>次，那么将会定义<code>N</code>次。单独分析判断语句它将会像第一层循环一样，一个判断<code>N</code>次，再算上第一次循环进入第二次循环共有<code>N</code>次， 故为<code>N * (N+1)</code>，后面类似<code>N*N</code>，其语句频度为:</p><script type="math/tex; mode=display">O_2=N+N*(N+1)+N*N\tag{1.2}</script></li><li><p>第二层循环进入最里面语句<code>N</code>次，第一层循环进入第二层循环共<code>N</code>次，故实际为<code>N * N</code>次。其语句频度为:</p><script type="math/tex; mode=display">O_3=N*N\tag{1.3}</script></li><li><p>那么将上述的<strong>（1.1）</strong>、<strong>（1.2）</strong>、<strong>（1.3）</strong>式子求和一下，就得这个程序的总的语句频次，并保留最高项数<code>N * N</code>，就得到了该程序的算法时间复杂度。</p><script type="math/tex; mode=display">O(N^2)=O_1+O_2+O_3\tag{1.4}</script></li></ol><p><strong>例子2</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>,i = <span class="hljs-number">1</span>;i &lt; N;i = i*<span class="hljs-number">2</span>)   <span class="hljs-comment">//1、</span><br>        sum = sum+i*j;             <span class="hljs-comment">//2、</span><br></code></pre></td></tr></table></figure><p>看到这程序片段，你是不是一眼就得出答案了？如果你不注意的话，你的答案肯定是<code>O(N)</code>，对了吗？<br>先告诉你答案为<code>O(log(N))</code>  不是这个答案的，你可以试试代个确切的N值进去 看一下次数,自己体会一下，那么下面我和大家一起分析下：</p><ol><li><p>注释1的语句频度为：</p><script type="math/tex; mode=display">O_1=1+log_2{N}+1+log_2{N}\tag{2.1}</script></li><li><p>注释2的语句频度为：</p><script type="math/tex; mode=display">O2=log_2{N}\tag{2.2}</script></li><li><p>总的算法时间复杂度为：</p><script type="math/tex; mode=display">O(log_2{N})=O_1+O_2\tag{2.3}</script></li></ol><p>其实这里做判断的时候，应该看一下循环变量的递增方式，这里它是<code>i=i*2</code>  也就是 <code>2^x=N</code>，那么<code>X=log2(N)</code>,<code>x</code>就是次数，在计算复杂度里面，一般省略底数，也就是直接写<code>log(N)</code>,其他的计算方法与上面的解释一致。</p><p><strong>例子3</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> sum=<span class="hljs-number">0</span>,i = <span class="hljs-number">0</span>;i&lt;N;i++)        <span class="hljs-comment">//1、</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>;j &lt; N;j = j*<span class="hljs-number">2</span>)     <span class="hljs-comment">//2、</span><br>        sum=sum+i*j;                <span class="hljs-comment">//3、</span><br></code></pre></td></tr></table></figure><p>答案分析:</p><ol><li><p>注释1的语句频度为：</p><script type="math/tex; mode=display">O_1=1+N+1+N\tag{3.1}</script></li><li><p>注释2的语句频度为：</p><script type="math/tex; mode=display">O_2=N+N*(log_2{N}+1)+N*log_2{N}\tag{3.2}</script></li><li><p>注释3的语句频度为：</p><script type="math/tex; mode=display">O_3=N*log_2{N}\tag{3.3}</script></li><li><p>总的算法时间复杂度为：</p><script type="math/tex; mode=display">O(N*log_2{N})=O_1+O_2+O_3\tag{3.4}</script></li></ol><p><strong>如果你认真仔细地边看边思考，那么我相信你应该是能够理解如何去计算时间复杂度了，那么任何程序相信在你们自己的简单化下，应该都能分出它们的大致大O阶。</strong><br> 那么，关于算法的时间复杂度就描述到这里，感谢你的浏览😄 </p><div class="note note-success">            <p>该博文是我对CSDN原博文进行了重新排版🤭</p>          </div>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C/C++</tag>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言中的预处理器</title>
    <link href="/2021/11/27/C%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8/"/>
    <url>/2021/11/27/C%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="预处理器"><a href="#预处理器" class="headerlink" title="预处理器"></a>预处理器</h2><blockquote><p>作者注:</p><p>最近在阅读<code>U-Boot</code>的源码时，发现在头文件中使用了较多的宏定义语句，顿时觉得这个宏在实现C语言程序可移植性特性起着重要作用，故本次简单地复习一下预处理器…</p></blockquote><span id="more"></span><p>编译一个C程序会经过四个阶段：预处理、编译、汇编、链接。而第一阶段的预处理阶段到底时做什么呢?答案就是:<strong>在源代码编译之前对其进行一些文本性质的操作</strong>。那么，什么是文本性质的操作呢? <strong>就个人理解来说，应该是想表达一种使用某种文本去替换另一种文本的操作</strong></p><p>它的主要任务有:</p><ul><li>删除注释</li><li>插入被<code>#include</code>指令包含的文件的内容。</li><li>定义和替换<code>#define</code>指令定义的符号。</li><li>确定代码的部分内容是否应该根据一些条件编译指令进行编译（这个在一些源码中蛮常见的，下面会简单说一下）。</li></ul><h3 id="一、预定义符号"><a href="#一、预定义符号" class="headerlink" title="一、预定义符号"></a>一、预定义符号</h3><p>预处理定义的符号可看如下表的内容</p><div class="table-container"><table><thead><tr><th>符号</th><th>样例值</th><th>含义</th></tr></thead><tbody><tr><td>__FILE__</td><td>“name.c”</td><td>进行编译的源文件名</td></tr><tr><td>__LINE__</td><td>25</td><td>文件当前行的行号</td></tr><tr><td>__DATE__</td><td>”Jan 31 1997“</td><td>文件被编译的日期</td></tr><tr><td>__TIME__</td><td>”18:04:30“</td><td>文件被编译的时间</td></tr><tr><td>__STDC__</td><td>1</td><td>如果编译器遵循ANSI C，其值就为1，否则未定义。</td></tr></tbody></table></div><p><strong>示例:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;__FILE__: %s\n__LINE__: %d\n__DATE__: %s\n__TIME__: %s\n__STDC__: %d\n&quot;</span>,__FILE__,__LINE__,__DATE__,__TIME__,__STDC__);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">在我本地运行</span><br><span class="hljs-comment">结果是:</span><br><span class="hljs-comment">__FILE__: D:\C_Code\test20\main.c </span><br><span class="hljs-comment">__LINE__: 4</span><br><span class="hljs-comment">__DATE__: Nov 25 2021</span><br><span class="hljs-comment">__TIME__: 20:59:37</span><br><span class="hljs-comment">__STDC__: 1</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>这些预定义符号，其实是不怎么常用的，简单了解即可。</p><h3 id="二、-define"><a href="#二、-define" class="headerlink" title="二、#define"></a>二、<code>#define</code></h3><h4 id="2-1-命名符号"><a href="#2-1-命名符号" class="headerlink" title="2.1 命名符号"></a>2.1 命名符号</h4><p><code>#define</code>常用的用法就是使用其为一个数值命名符号，它的正式描述及一些示例:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 每当有符号name出现在这条指令的后面时，预处理器就会把它替换为stuff</span><br><span class="hljs-comment">* 这个name不仅仅可以使用数值字面值常量，它可以是任何文本</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> name stuff</span><br><br><span class="hljs-comment">//示例1. 为关键字register创建一个简短的别名</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> reg register</span><br><span class="hljs-comment">//示例2. 用一个更具描述性的符号表示实现无限循环的for语句</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> do_forever for(;;)</span><br><span class="hljs-comment">//示例3. 用CASE 替换常规的 case关键字，自动地在每个case前增加了break，避免了使用switch时忘记添加break。</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CASE break;case</span><br></code></pre></td></tr></table></figure><p>当然，<code>stuff</code>也可以定义多行，如果你的<code>stuff</code>很长的话，它的示例:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 这里C语言中有一个特性: 相邻字符串常量可以被自动连接为一个字符串。</span><br><span class="hljs-comment">* 通过使用反斜杠 \ stuff 可以定义多行。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PRINT_TEST printf(<span class="hljs-meta-string">&quot;__FILE__: %s\n__LINE__: %d\n&quot;</span>\</span><br><span class="hljs-meta">        <span class="hljs-meta-string">&quot;__DATE__: %s\n__TIME__: %s\n__STDC__: %d\n&quot;</span>, \</span><br><span class="hljs-meta">        __FILE__,__LINE__,__DATE__,__TIME__,__STDC__);</span><br></code></pre></td></tr></table></figure><p>:triangular_flag_on_post:注意:<strong>建议不要在宏定义的尾部加上分号，如果你加了分号，就会在下文的没有宏的语句加分号与有宏的语句中不加分号之间产生混淆。</strong></p><h4 id="2-2-宏的使用"><a href="#2-2-宏的使用" class="headerlink" title="2.2 宏的使用"></a>2.2 宏的使用</h4><p><code>#define</code>允许把参数替换到文本中，该实现通常被称为<strong>宏</strong>或<strong>定义宏</strong>，它的声明方式为:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* parameter-list 参数列表是一个由逗号分隔的符号列表，它们可能出现在stuff中。</span><br><span class="hljs-comment">* 参数列表的左括号必须与name紧邻，若两者之间存在空白，参数列表就会被解释为stuff的一部分</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> name(parameter-list) stuff</span><br><br></code></pre></td></tr></table></figure><p>当宏被使用时，参数列表中的参数的实际调用值江湖被替换到<code>stuff</code>中，下面是一些示例。</p><p><strong>示例</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SQUARE(x) x*x</span><br></code></pre></td></tr></table></figure><p>如果你在程序中使用该宏，并提供一个参数<code>10</code>，即使用<code>SQUARE(10)</code>，那么预处理器将会使用表达式<code>10 * 10</code>替换。</p><p><strong>易被忽视的坑</strong></p><p>假设在程序有如下的这个程序片段:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">a = <span class="hljs-number">5</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,SQUARE(a+<span class="hljs-number">1</span>));<br><span class="hljs-comment">//也许你会想，这结果应该是 36 可惜的是：它不是，而是 11</span><br></code></pre></td></tr></table></figure><p>它这个<code>a+1</code>并不会先进行计算，预处理器只是将其当作一个文本替换掉<code>stuff</code>部分的<code>x*x</code>，也就是变成了<code>5+1*5+1</code>，显而易见，结果是<code>11</code>。如果你想结果为<code>36</code>，那么我们只需为其添加一对括号就行。</p><h4 id="2-3-替换"><a href="#2-3-替换" class="headerlink" title="2.3 替换"></a>2.3 替换</h4><p><strong>替换三步骤</strong></p><ol><li><p>在调用宏的时候，首先对参数进行检查，看看是否包含了任何由<code>#define</code>定义的符号。如果是，则它们首先会被替换。</p></li><li><p>替换文本随后被插入到程序中原来文本的位置。对于宏，其参数名会被值所替代。</p></li><li><p>最后，再次对结果文本进行文本扫描，如果还包含<code>#define</code>定义的符号，重复上诉步骤</p></li></ol><p><strong>宏参数和<code>#define</code>定义可以包含其他#define定义的符号，但宏不可以出现递归。</strong></p><p><strong>将宏参数插入字符串常量</strong></p><ul><li><p>使用邻近字符串自动连接的特性将字符串分成几段，每一段都是一个宏参数。（这个技巧显然只能针对参数为字符串常量的）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PRINT(FORMAT,VALUE) \</span><br><span class="hljs-meta">        printf(<span class="hljs-meta-string">&quot;The Value is &quot;</span>FORMAT<span class="hljs-meta-string">&quot;\n&quot;</span>,VALUE)</span><br>...<br><span class="hljs-comment">//在程序中的使用方式</span><br>PRINT(<span class="hljs-string">&quot;%d&quot;</span>,<span class="hljs-number">10</span>);<br><br></code></pre></td></tr></table></figure></li><li><p>将一个宏参数转换为一个字符串。</p><ul><li><p>使用<code>#argument</code>，它会被翻译为<code>argument</code>,不涉及任何其他动作，字面替换。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PRINT(VALUE) \</span><br><span class="hljs-meta">        printf(<span class="hljs-meta-string">&quot;The expression is &quot;</span> \</span><br><span class="hljs-meta">        #VALUE <span class="hljs-meta-string">&quot;\n&quot;</span>,VALUE)</span><br>...<br><span class="hljs-comment">//在程序中的使用方式</span><br>PRINT(<span class="hljs-number">10</span>+<span class="hljs-number">10</span>);<br><span class="hljs-comment">// 输出为: The expression is 10+10</span><br></code></pre></td></tr></table></figure></li><li><p>使用<code>##</code>结构，它会将位于其两边的符号连接成一个符号。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ADD_TO_SUM(sum_number,value) \</span><br><span class="hljs-meta">                sum ## sum_number += value</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> sum5=<span class="hljs-number">20</span>;<br>    ADD_TO_SUM(<span class="hljs-number">5</span>,<span class="hljs-number">10</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,sum5);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">// 相当于 sum 与 5 进行连接，即 stuff 实际变成了 sum5 += 10;</span><br></code></pre></td></tr></table></figure></li></ul></li></ul><h4 id="2-4-宏与函数"><a href="#2-4-宏与函数" class="headerlink" title="2.4 宏与函数"></a>2.4 宏与函数</h4><p>如果我们想要执行一些简单的计算，如求两数最大值，可以尝试着使用宏。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 这里使用括号是避免使用参数时出现之前提过的坑。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX(a,b) ((a)&gt;(b)?(a):(b))</span><br></code></pre></td></tr></table></figure><p>当然，实现这个也可以使用函数，但是你需要考虑一些东西。</p><ul><li>程序规模会比宏大</li><li>函数是需要栈参与到其中的，可能会带来一些额外的时间花销。</li><li>函数的参数必须声明为一种特定的类型。</li></ul><p><strong>宏的不利之处:</strong> 其定义代码的拷贝将插入程序中，如果太长的话，将会大幅度增加程序的长度。</p><p>当然，有一些任务函数是无法做到的，如:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//type 是一个类型，无法作为函数参数传递。</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MALLOC(n,type) \</span><br><span class="hljs-meta">((type *)malloc ((n)*sizeof(type)))</span><br></code></pre></td></tr></table></figure><p>如果你在使用宏时，宏参数在定义中出现的次数超过一次，若参数具备“副作用”，那么当你使用这个宏时将会出现危险，导致不可预料的结果。<strong>副作用:</strong> 在表达式求值时出现的永久性结果。</p><p><strong>示例</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">int</span> x = <span class="hljs-number">5</span>, y = <span class="hljs-number">8</span>;<br><span class="hljs-keyword">int</span> z = MAX(x++,y++);<br><span class="hljs-comment">//结果是 x = 6,y = 10,z = 9。 好好思考一下这是为什么呢?</span><br></code></pre></td></tr></table></figure><p>因为<code>#define</code>宏的行为和真正的函数相比存在一些不同的地方，区别如下:</p><div class="table-container"><table><thead><tr><th>属性</th><th><code>#define</code>宏</th><th>函数</th></tr></thead><tbody><tr><td>代码长度</td><td>每次使用时，宏代码都被插入程序中，除了非常小的宏之外，程序的长度将会大幅度增长</td><td>函数代码只出现于一个地方，每次使用这个函数时，都调用哪个地方的同一份代码。</td></tr><tr><td>执行速度</td><td>更快</td><td>存在函数调用/返回的额外开销。</td></tr><tr><td>操作符优先级</td><td>宏参数的求值是在所有周围表达式的上下文环境里，除非它们加上括号，否则邻近操作符的优先级可能会产生不可预料的结果。</td><td>函数参数只在函数调用时求值一次，它的结果值传递给函数，表达式的求值结果更容易预测。</td></tr><tr><td>参数求值</td><td>参数每次用于宏定义时，它们都重新求值。由于多次求值，具有副作用的参数可能会产生不可预料的结果。</td><td>参数在函数被调用前只求值一次。在函数中多次使用参数并不会导致多种求值过程。参数的副作用并不会造成任何特殊的问题。</td></tr><tr><td>参数类型</td><td>宏与类型无关。</td><td>与类型有关。</td></tr></tbody></table></div><h4 id="2-5-其他"><a href="#2-5-其他" class="headerlink" title="2.5 其他"></a>2.5 其他</h4><p><strong><code>#undef</code></strong></p><p>该指令用于移除一个宏定义。用法；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">undef</span> name</span><br></code></pre></td></tr></table></figure><p><strong>命令行定义</strong></p><p>有时，你可以在一些编译器中看到<code>-Dxxx</code>啥的，这就是表示你在定义一些符号。</p><p><strong>示例</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">-Dname<br>-Dname=stuff<br></code></pre></td></tr></table></figure><h3 id="三、条件编译"><a href="#三、条件编译" class="headerlink" title="三、条件编译"></a>三、条件编译</h3><p>在编译一个程序时，若我们可以选择某条语句或某组语句进行翻译或者被忽略，常常会显得很方便。使用条件编译你将会很容易达到这个目的。</p><p><strong>它的简单语法形式:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* constant-expression 是一个常量表达式，由预处理器进行求值。非零值表 真。</span><br><span class="hljs-comment">* 如 constant-expression 为真 statements部分就会被编译。</span><br><span class="hljs-comment">* constant-expression 可以是 字面值常量 也可以是由 #define定 义的符号</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> constant-expression</span><br>statements<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span> </span><br></code></pre></td></tr></table></figure><p><strong>示例</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//想编译就将DEBUG置为非0值，不然就置为0</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DEBUG 1</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> DEBUG</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;x=%d,y=%d\n&quot;</span>,x,y);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p><strong>它的完整语法:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> constant-expression</span><br>statements<br><span class="hljs-meta">#<span class="hljs-meta-keyword">elif</span> constant-expression</span><br>    others statements<br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span> constant-expression</span><br>others statements<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span> </span><br></code></pre></td></tr></table></figure><p><code>#elif</code>可以出现多次，这个结构与我们程序中的<code>if else</code>类似。</p><p><strong>预处理器提供了几种可以测试一个符号是否已被定义的方式:</strong></p><ul><li><code>#if defined(symbol)</code></li><li><code>#ifdef symbol</code></li></ul><ul><li><code>#if !defined(symbol)</code></li><li><code>#ifndef symbol</code></li></ul><p>每对定义的两条语句是等价的。</p><p>如果你在<code>#if</code>使用到嵌套指令，记住请在<code>#endif</code>添加一些注释，这样读者能够记住你这个嵌套指令对应哪一层。</p><h3 id="四、文件包含"><a href="#四、文件包含" class="headerlink" title="四、文件包含"></a>四、文件包含</h3><p>入门<code>C</code>语言的时候，也许我们就已基本了解<code>#include</code>指令是使另一个文件的内容被编译。这种替换的执行方式: 预处理器删除这条指令，并用包含文件的内容取而代之。这样的话，它被包含几次，它实际上就被编译几次。所以它会产生一些小小的开销，所以你需要注意一下:</p><ul><li>头文件应该只包含一组函数或数据的声明。</li></ul><h4 id="4-1-函数库文件包含"><a href="#4-1-函数库文件包含" class="headerlink" title="4.1 函数库文件包含"></a>4.1 函数库文件包含</h4><p>函数库文件包含使用下面的语法:</p><p><strong><code>#include &lt;filename&gt;</code></strong></p><p>这个是由编译器去观察由编译器定义的“一系列标准位置”查找函数库头文件。</p><h4 id="4-2-本地文件包含"><a href="#4-2-本地文件包含" class="headerlink" title="4.2 本地文件包含"></a>4.2 本地文件包含</h4><p>本地文件包含使用下面的语法:</p><p><code>#include &quot;filname&quot;</code></p><p>这个也是由编译器自行决定是否把本地形式的<code>#include</code>和函数库形式的<code>#include</code>区别对待。常见策略是:在源文件所在的当前目录进行查找。</p><h4 id="4-3-嵌套文件包含"><a href="#4-3-嵌套文件包含" class="headerlink" title="4.3 嵌套文件包含"></a>4.3 嵌套文件包含</h4><p>在涉及嵌套文件包含的过程中，就能遇到一个头文件会被多次被包含。考虑一个例子:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//看下面这个好像没有什么问题。</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;a.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;b.h&quot;</span></span><br><span class="hljs-comment">//但是如果 a.h 和 b.h都包含一个x.h的话，x.h就被多重包含了。</span><br></code></pre></td></tr></table></figure><p>为了解决这个问题，我们可以使用条件编译，如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> _HEADERNAME_h </span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> _HEADERNAME_h 1</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 这里包含一些声明</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br></code></pre></td></tr></table></figure><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p>[1] Kenneth A. Reek. C和指针[M]. 人民邮电出版社, 2008.</p>]]></content>
    
    
    <categories>
      
      <category>C/C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C/C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux内核学习(一)：操作系统的基本概念</title>
    <link href="/2021/11/24/Linux%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0-%E4%B8%80-%EF%BC%9A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <url>/2021/11/24/Linux%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0-%E4%B8%80-%EF%BC%9A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本系列将开启对Linux内核的学习之旅…</p></blockquote><span id="more"></span><h3 id="一、操作系统的基本概念"><a href="#一、操作系统的基本概念" class="headerlink" title="一、操作系统的基本概念"></a>一、操作系统的基本概念</h3><blockquote><p>任何计算机系统都包含一个名为<strong>操作系统</strong>的基本程序集合。该集合中，最为重要的程序被称为<strong>内核(<code>kernel</code>)</strong>，操作系统启动时，内核被装载至<strong>RAM（通常指的是人们所熟知的内存）</strong>中，而内核包含了系统运行所必不可少的很多核心过程(procedure)。可以这么说，<strong>系统的根本的样子和能力是由内核决定的</strong>。</p></blockquote><p>操作系统必须完成的两个主要目标:</p><ul><li>与硬件部分进行交互，为包含在硬件平台上的所有底层可编程部件提供服务。</li><li>为运行在计算机系统上的应用程序（即所谓用户程序）提供执行环境。</li></ul><p>一些操作系统会允许所有的用户程序都直接与硬件进行交互，如<strong>MS-DOS</strong>，而<strong>类Unix操作系统把与计算机物理组织相关的所有底层细节都对用户运行的程序隐藏起来。</strong>这时，如果应用程序想要访问硬件资源的话，则需向操作系统发出请求，并由内核进行评估，如果允许，则由内核代表应用程序与相关硬件进行交互。为了实现这种机制，硬件为CPU引入了至少两种不同的执行模式：<strong>用户程序的非特权模式</strong>和<strong>内核的特权模式</strong>。Unix把它们称为<strong>用户态（User Mode）</strong>和<strong>内核态（Kernel Mode）</strong>。</p><h4 id="1-1-多用户系统"><a href="#1-1-多用户系统" class="headerlink" title="1.1 多用户系统"></a>1.1 多用户系统</h4><blockquote><p>一台能够<strong>并发</strong>和<strong>独立</strong>地执行分别属于两个或多个用户的若干应用程序的计算机。Unix是实施系统资源硬件保护的多用户系统。</p></blockquote><p><strong>并发（concurrently）</strong>：几个应用程序能同时处于活动状态并竞争各种资源。</p><p><strong>独立（independently）</strong>：每个应用程序能执行自己的任务，无需考虑其他用户的应用程序在干什么。</p><p>该类需包含的特点:</p><ul><li>核实用户身份的认证机制。</li><li>防止有错误的用户程序妨碍其他应用程序在系统中允许的保护机制。</li><li>防止有恶意的用户程序干涉或窥视其他用户的活动的保护机制。</li><li>限制分配给每个用户的资源数的记账机制。</li></ul><h4 id="1-2-用户和组"><a href="#1-2-用户和组" class="headerlink" title="1.2 用户和组"></a>1.2 用户和组</h4><p>在多用户系统中，每个用户在机器上都有私有空间，即他拥有一定数量的磁盘空间来存储文件、接收私人邮件信息等。<strong>操作系统需保证用户空间的私有性</strong>。所有用户由唯一的数字标识，即<strong>用户标识符（User ID,UID）</strong>。若用户要开启工作会话，一般操作系统都会要求输入一个登录名和口令，若认证不通过，则系统拒绝访问。</p><p>为了能够更好的和其他用户进行共享资料，每个用户是一个或多个用户组的一名成员，组由唯一的<strong>用户组标识符(user group ID)</strong>标识。组内用户对文件具备一定的权限，而组外用户则无任何访问权限。</p><p>任何类Unix操作系统都有一个特殊的用户，叫做<code>root</code>，即<strong>超级用户（<code>superuser</code>）</strong>，系统管理员需以该身份登录系统以便管理用户账号。<code>root</code><strong>用户能访问系统中的每一个文件，能干涉每一个正在执行的用户程序的活动。</strong></p><h4 id="1-3-进程"><a href="#1-3-进程" class="headerlink" title="1.3 进程"></a>1.3 进程</h4><blockquote><p>所有操作系统都使用一种基本的抽象：进程(process)。进程的定义: 程序执行时的一个实例，或一个运行程序的“执行上下文”。</p></blockquote><p>对于传统的操作系统，一个进程在地址空间(<code>address space</code>)中执行一个单独的指令序列（现代操作系统允许在相同的地址空间执行多个指令序列）。</p><blockquote><p>地址空间是<strong>允许进程引用的内存地址集合</strong>。</p></blockquote><p>允许进程并发活动的系统被称为多道程序系统(<code>multiprogramming</code>)或多处理系统(<code>multiprocessing</code>)。</p><p>程序和进程的区别: <strong>几个进程能够并发地执行同一程序，而同一个进程能顺序地执行几个程序</strong>。</p><p>在单处理器系统上，只有一个进程能占用CPU，因此，在某一时刻只能有一个执行流。操作系统中存在一个名为<strong>调度程序</strong>的部分用于决定哪个进程能够进行。存在一些操作系统只允许有非抢占式进程，即只有进程自愿放弃CPU时，调度程序才能被调用。<strong>而多用户系统中的进程必须时抢占式的，操作系统记录下每个进程占有的CPU时间，并周期性地激活调度程序。</strong>Unix是具有抢占式进程的多处理操作系统，Unix操作系统采用进程/内核模式。每个进程都自以为其是系统中唯一的进程，可以独占操作系统所提供的服务。<strong>只要进程发出系统调用，硬件就会把特权模式由用户态变成内核态，若该请求得到满足。内核过程将迫使硬件返回用户态，然后进程从系统调用的下一条指令继续执行</strong>。</p><h4 id="1-4-内核体系结构"><a href="#1-4-内核体系结构" class="headerlink" title="1.4 内核体系结构"></a>1.4 内核体系结构</h4><blockquote><p>大部分Unix内核是单块结构：每一个内核层都被集成到整个内核程序中，并代表当前进程在内核态下运行。相反，微内核(<code>microkernel</code>)操作系统只需要内核有一个很小的函数集合，通常包括几个同步原语、一个简单的调度程序和进程间通信进制。运行在微内核之上的几个系统进程实现从前操作系统级实现的功能，如内存分配程序、设备驱动程序、系统调用处理程序等。</p></blockquote><p>微内核操作系统的<strong>缺点</strong>:</p><ul><li>效率低，操作系统不同层次之间显示的消息传递要花费一定的代价。</li></ul><p>微内核操作系统的<strong>优点</strong>：</p><ul><li>模块化方法。</li><li>易移植。</li><li>充分利用RAM。</li></ul><p>为了达到微内核理论上的很多优点而又不影响性能，<code>Linux</code>内核提供了模块(<code>module</code>)。模块属于目标文件，其代码可以在运行时链接到内核或从内核解除链接。这种目标代码通常由一组函数组成，用于实现文件系统、驱动程序或其他内核上层功能。与微内核的操作系统的外层不同，模块不是作为一个特殊进程执行的。相反，与任何其他的静态链接的内核函数一样，它代表当前进程在内核态下执行。</p><p>使用模块的主要优点:</p><ul><li>模块化方法。<ul><li>任何模块可在运行时被链接或解除链接。故系统程序员必须提出良定义的软件接口以访问模块处理的数据结构，这使得开发新模块变得容易。</li></ul></li><li>平台无关性。<ul><li>即使模块依赖于某些特殊的硬件特点，但它不依赖于某个固定的硬件平台。</li></ul></li><li>节省内存使用<ul><li>当需要模块功能时，把它链接到正在运行的内核中，否则，将该模块解除链接。</li></ul></li><li>无性能损失。<ul><li>模块的目标代码一旦被链接到内核，其作用与静态链接的内核的目标代码完全等价。故当模块的函数被调用时，无需显示地进行消息传递。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>修改equals方法时为什么还要重写hashcode方法?</title>
    <link href="/2020/06/22/%E4%BF%AE%E6%94%B9equals%E6%96%B9%E6%B3%95%E6%97%B6%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81%E9%87%8D%E5%86%99hashcode%E6%96%B9%E6%B3%95/"/>
    <url>/2020/06/22/%E4%BF%AE%E6%94%B9equals%E6%96%B9%E6%B3%95%E6%97%B6%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81%E9%87%8D%E5%86%99hashcode%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<blockquote><p>虽然在实际开发中，我们已经使用到散列集合(如<code>HashMap</code>),或也单独学过散列（<code>Hash</code>）。但是也会有很多人像我一样，看到有些时候别人写的<code>pojo</code>中有对对象内<code>hashcode</code>函数做一个重写，这就让我重新思考为什么要这么做? 下面就让我和你一起去探索一下吧!</p></blockquote><span id="more"></span><h2 id="一、Hash是什么"><a href="#一、Hash是什么" class="headerlink" title="一、Hash是什么?"></a>一、Hash是什么?</h2><p>Hash就是上文说到的散列，是把任意长度的输入(又叫做预映射pre-image）通过散列算法变换成固定长度的输出，该输出就是散列值。它的理论时间复杂度是可以达到O(1),但一般来说，这个散列函数是极难设计的。说到散列值，就是通过散列函数转化出来的:</p><ul><li>如果两个散列值是不一样y(x1)!=y(x2)，那么这两个散列值的原始输入一定是不一样的。</li><li>如果两个散列值出现了相等，那么并不代码这两个散列值的原始输入一定是一样的，可能是属于哈希碰撞(不同关键字经过散列变换结果是一样的的现象);</li></ul><p>对于哈希函数有哪些我也不再介绍，想了解可以直接去查散列函数的。</p><h2 id="二、Hashcode作用"><a href="#二、Hashcode作用" class="headerlink" title="二、Hashcode作用"></a>二、Hashcode作用</h2><p>很多情况下我们也许都会用到hash表来做提高查询效率，那么这个hash表是如何提高效率的?其实就是基于上面所说的散列函数，根据设计的散列函数，我们对于每一个关键字都有唯一的散列值，那么就能够直接根据这个散列值直接就能找到元素在集合中的位置，从而获得其值，这对于集合的一个个对象进行比较来说，是提高了很多的。</p><p><img src="/images/java-hash.png" alt="java-hash"></p><p>通过以上操作，我们很容易就能理解为啥散列技术在查询的复杂度是能达到O(1).</p><p>但是一般来说<code>java</code>都会内置了<code>hashcode</code>的实现,那为什么在写对象的时候，只要对<code>equals</code>进行重写，都推荐对<code>hashcode</code>进行重写呢?</p><p>看<code>HashCode</code>的常规协定：</p><blockquote><ul><li>在 Java 应用程序执行期间，在同一对象上多次调用 hashCode 方法时，必须一致地返回相同的整数，前提是对象上 equals 比较中所用的信息没有被修改。从某一应用程序的一次执行到同一应用程序的另一次执行，该整数无需保持一致。<br>如果根据 equals(Object) 方法，两个对象是相等的，那么在两个对象中的每个对象上调用 hashCode 方法都必须生成相同的整数结果。 </li><li>这种情况不 是必需的：如果根据 equals(java.lang.Object) 方法，两个对象不相等，那么在两个对象中的任一对象上调用 hashCode 方法必定会生成不同的整数结果。但是，程序员应该知道，为不相等的对象生成不同整数结果可以提高哈希表的性能。 </li><li><p>实际上，由 Object 类定义的 hashCode 方法确实会针对不同的对象返回不同的整数。（这一般是通过将该对象的内部地址转换成一个整数来实现的，但是 JavaTM 编程语言不需要这种实现技巧。） </p></li><li><p>当equals方法被重写时，通常有必要重写 hashCode 方法，以维护 hashCode 方法的常规协定，该协定声明相等对象必须具有相等的哈希码。</p></li></ul></blockquote><p>根据以上知道，<code>java</code>内部的一个实现是以地址来的，如果对<code>equals</code>进行重写了，也就是对象你判断相等时不再以<code>java</code>提供的方法，那么将来在使用<code>hash</code>表的时候，就会存在<code>equals</code>是相等的，但<code>hashcode</code>却是不相等的!</p><p>所以建议:<strong>在修改<code>equals</code>的方法时，记得修改<code>hashcode</code>方法!!!</strong></p><p>下面做个小例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span>: Kilig</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span>: 2020/6/22 21:18</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span>:</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> id;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.id = id;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object o)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == o) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        <span class="hljs-keyword">if</span> (!(o <span class="hljs-keyword">instanceof</span> User)) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        User user = (User) o;<br>        <span class="hljs-keyword">return</span> getId() == user.getId();<br>    &#125;<br><br><span class="hljs-comment">//    @Override</span><br><span class="hljs-comment">//    public int hashCode() &#123;</span><br><span class="hljs-comment">//        return Objects.hash(getId());</span><br><span class="hljs-comment">//    &#125;</span><br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>       User a=<span class="hljs-keyword">new</span> User();<br>       User b=<span class="hljs-keyword">new</span> User();<br>       a.setId(<span class="hljs-number">1</span>);<br>       b.setId(<span class="hljs-number">1</span>);<br>       System.out.println(a.equals(b));<br>       System.out.println(a.hashCode() == b.hashCode());<br><br>   &#125;<br></code></pre></td></tr></table></figure><p>运行结果:</p><p><img src="/images/java-hashcode-2.png" alt="java-hashcode-2"></p><p>尝试将其放到<code>set</code>集合时:</p><p><img src="/images/java-hashcode3.png" alt="java-hashcode3"></p><p>看到这结果显然不是我们想要的，因为我两个对象相等，其<code>hashcode</code>也应相等,然而结果却是在不可重复的set集合中存了两个对象，所以我们做一个改进，对<code>User</code>进行重写<code>hashcode</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span> </span>&#123;<br>      <span class="hljs-keyword">return</span> Objects.hash(getId()); <span class="hljs-comment">//使用默认的hash函数处理关键字，这里是ID，我们认为Id相等的用户其就是同一个用户</span><br>  &#125;<br></code></pre></td></tr></table></figure><p>然后看看set的结果:</p><p><img src="/images/java-hashcode4.png" alt="java-hashcode4"></p><p>的确符合我们预期结果。</p><p>基于以上的学习，我们也基本了解为啥在修改<code>equals</code>方法时也要对<code>hashcode</code>进行修改。</p><p><strong>感谢你的浏览…</strong></p>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JAVA进阶知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
